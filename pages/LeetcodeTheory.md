public:: true

- # 尾递归及其优化
	- https://zhuanlan.zhihu.com/p/36587160
	- goto和尾递归是否等价？
		- 不清楚，但是尾递归可以通过goto来实现。
	- 尾递归空间复杂度就一定比普通递归低？就一定不会发生“爆栈”现象？
		- 有一个非常大的误区：尾递归有两种特殊情况，一是递归函数在最后一层递归打印出结果，则不需要向上层返回变量，二是函数中有return关键字的时候，则需要向上返回结果，但无论哪种情况下，都会保存像普通递归那样保留入口环境，所以空间占用和普通递归是一样的。区别就只有，下一层递归完成之后，回到当前入口环境之后，即刻向上返回，而没有在当前入口环境执行其他消耗时间的行为。
		- 尾递归优化思路的理解：
			- 乍一看，优化的尾递归代码与尾递归函数的区别就在于：把迭代过程 转换成了 循环过程，每一次循环都执行同一个函数，函数执行的实际参数并不是中间变量而是全局变量，函数每执行一遍会改变全局变量的结果，也就是会改变下一次函数执行时的实际参数。
			- 可以观察到，起码会涉及到两个全局变量：
				- 一个变量对应于递归过程中控制递归层数和递归终点的层次变量，其在循环中用于控制循环的结束，这个变量会在参数部分使用诸如n - 1或者n + 1来进行层次的变化；
				- 另一个变量对应于递归过程需要执行的计算结果或者说返回值，而且可以发现每层的返回值和每层的层数都是相关的，所以每层的计算表达式中都会包含第一个变量，可以说第二个变量在某种程度上依赖于第一个变量。
			- 尾递归的优化实现又被叫做循环迭代函数
			- 尾递归优化可以手动实现，也可以由编程语言自身进行支持
	- 尾调用是什么？尾递归和尾调用的区别是什么？
		- 尾调用 = 尾 + 调用， 就是指在函数的结束位置或者说最后一个执行语句处来调用一个函数。如果这个调用的函数恰好是函数自己本身，就被称作是尾递归了。显然，尾递归是尾调用的一种特殊情况。
		- 尾调用不一定是递归过程。
- # 递归栈的空间复杂度问题
  collapsed:: true
	- https://stackoverflow.com/questions/43298938/space-complexity-of-recursive-function
	- 递归过程的空间复杂度只跟递归深度或者说递归的次数有关，其时间复杂度才与递归树叶子节点或者说需要计算的base case的总数目相关。千万不要认为递归过程的空间复杂度等于其时间复杂度，因为递归树的每个层次虽然通常展开了多个分支，但是这同一层的每个分支其计算结果是同时由下层分支向上回溯得到的，并且这每个分支的结果会被堆叠或者相加在一起，而不是分散开的。
	-
- # 有哪些隐藏的栈结构？
- # 递归的非循环实现除了加快速度，还有什么作用？
- # 并查集
  collapsed:: true
	- 基本描述：
	  collapsed:: true
		- ![image.png](../assets/image_1662168644818_0.png){:height 359, :width 876}
	- 理解：
	  collapsed:: true
		- 并查集中的集合该怎么理解？用什么逻辑结构实现要好呢？
			- 并查集中的集合从概念上类似与List、数组、堆栈等，都是用于存储一组元素的，区别在于为实现不同的操作而定义了不同的存储元素、获取元素的规则。list存储的一组元素之间有先后顺序，数组存储的元素通常有空间位置上的对应关系、堆栈有逻辑上的操作顺序，而并查集中的集合其具体结构必须要能够方便实现 F1 =【查询两元素是否处于同一个集合】以及 F2 =【合并两个元素所在的集合】这两个功能。
			- 能否使用普通的List逻辑结构来实现并查集中的集合呢？
			  collapsed:: true
				- 可以，这时候需要用二维list来存储，其每一行都对应于一个集合。实现F1，先需要查找元素A和B分别在哪一行中，很明显这个查找的复杂度 最好情况下为O(1)，最坏情况下为O(N)，平均复杂度O(N)；实现F2,  这里则先需要执行F1，如果本身就在一个集合里，就无需合并，或者说合并复杂度就是O(1)，如果不在一个集合里，则 将一维数组 A 和 一维数组 B 拷贝到一个新数组中去，并释放原有的A空间和B空间，复杂度为O(len(A) + len(B))，总的来说复杂度还是O(N)。很明显，需要执行F1和F2的次数很多，这样实际的复杂度就接近O(N^2)了。
				- 因为并查集的集合是个整体的概念，元素之间的顺序是没有要求的，所以两个集合的元素怎么混合是没有要求的。用list合并的时候必然是直接连接最为方便。
			- List版本的实现存在什么问题？可以如何优化？
				- 因为list是个线性结构，不论是查找还是合并，都是在一维的空间上展开的，没有其他特殊条件时没有捷径可走或者说不能跳步骤。
				- 可以使用tree的逻辑结构来代表集合，一个tree代表一个集合。
					- F1操作即为，判断两个元素所在的树是否具有相同的根，如果根一样就说明是在同一棵树上；
					- F2操作即为，将两棵树合并成一棵，这十分类似于将森林转换成一棵树的场景（此场景下是将森林中的每棵树都转化为二叉树，然后第一棵二叉树的根结点作为合并树的根结点，后面二叉树的根结点依次作为前面一棵二叉树的右孩子）
						- ![image.png](../assets/image_1662207802234_0.png)
						- 可以借鉴其思想在根结点处执行合并操作
							- 因为此处涉及的合并操作次数会远比森林频繁，所以可以直接使用多叉树；
							- 因为合并后的树会被用到后续的F1操作中，我们必然希望合并后树的高度越小越好，所以不采纳多个树彼此之间作为后孩子的做法，而是统一连接到根结点上去。
							- 集合的树高和数量在这里是对应的，树中结点数目越多，对应的树越高。所以两棵树合并时，小树或者说矮树的根结点接到大树或者高树的根结点上面去，同样是为了合并后树高尽可能小。
							  collapsed:: true
								- ![24ed684ff51dbcd25eaa005f065fbff.jpg](../assets/24ed684ff51dbcd25eaa005f065fbff_1662214203203_0.jpg)
								- 这两棵树 都是 并查集中可能出现的。左边共有7个结点，右边共有5个结点。按照并查集的规定，应该是把右边的挂在左边的根结点上，这样形成的新的高度是4。但是如果把左边挂在右边的根结点上，形成的新的高度是3。所以，难道不是后面这种做法好吗？因为这样树的高度更低了。不对，不应该是以树的整体高度来作为标准，而是以叶子节点的平均高度为标准，很明显按照并查集的规定，把数目少的tree挂在数目多的tree的根结点上，叶子节点查找根结点的平均高度是最短的，所以并不矛盾。
							- 可以发现，任何一棵高度大于2的树必然是由两颗高度都大于1的树合并而成的。
							-
							-
					-
				-
		- 并查集有什么作用？
			- 并查集中有两点没有说明：
				- 什么样的两个元素才会被放在同一个集合？
				- 什么时候两个元素所在的集合才需要合并？
			- 为啥不说明呢？
				- 说明不重要，说明 这两个标准  完全可以依据具体情况而有各种选择，并查集只是快速执行集合这两种运算的一种数据结构。
	- 并查集的实现细节：
	  collapsed:: true
		- 初始时每个结点自己的根结点都是自己
		  collapsed:: true
			- ![image.png](../assets/image_1662169433248_0.png)
		- 合并操作是进行逻辑树的合并，并不一定需要物理上的逻辑指针来合并，可以通过hashmap<结点，结点的父亲>这种结构来维护整棵树的结构
		  collapsed:: true
			- ![image.png](../assets/image_1662170475602_0.png)
			- ![image.png](../assets/image_1662170688953_0.png)
			- ![image.png](../assets/image_1662170762104_0.png)
			- ![image.png](../assets/image_1662171239353_0.png)
		- 由于合并时需要比较两棵树的大小，所以需要存储 <树的根结点，树的大小>的 map
		  collapsed:: true
			- ![image.png](../assets/image_1662171289893_0.png)
		- F1和F2都需要找到元素所在树的根结点，合并树的操作能尽可能降低树的高度，但是依旧有可能形成如下图所示这种多层级联的树，在底层的结点向上寻找根结点的过程中，可以把沿途的结点都保存下来，当找到根结点后，将这些沿途结点的父亲指针都指向根结点，这样可以减少再次搜索的时间消耗。
		  collapsed:: true
			- ![image.png](../assets/image_1662173287419_0.png)
			- ![image.png](../assets/image_1662173432008_0.png)
	- 复杂度：N越大，越接近O(1)
	  collapsed:: true
		- ![image.png](../assets/image_1662175157756_0.png)
		-
	- 代码的优化：
	  collapsed:: true
		- ![image.png](../assets/image_1662175624684_0.png)
		-
	- 应用案例：
	  collapsed:: true
		- ![image.png](../assets/image_1662277457697_0.png)
		- ![image.png](../assets/image_1662278723823_0.png)
		-
- # 记忆化搜索
- # 回溯
- # 卡特兰数
  collapsed:: true
	- ![image.png](../assets/image_1664523564327_0.png)
	- ![image.png](../assets/image_1664523590222_0.png)
	  collapsed:: true
		- 理解：
			- 只要项的值满足三者中的任意一种形式，都是卡特兰数。
			- 三种形式是否等价呢？
				- 一种可能是：在数学的数值结果上是等价的？
				- 另一种可能是：在数值结果上是不等价的，但是在数学形式的含义是等价的？
		- 形式一的理解：
		  collapsed:: true
			- 问题：
				- 二叉树由N个无差别的结点组成，组成的结构有多少种？
			- 解题思路概括：
				- 任何一棵复杂二叉树都是由根、左子树、右子树这三个部分组成的。根是固定的，结构的区别是由左子树和右子树决定的。左右子树的结点总数是固定的，分配到左右两个子树一共有N种可能性。注意左子树有i个结点、右子树有j个结点，和左子树有j个结点、右子树有i个结点是不同的，因为二叉树中左右子树有别。
			- 解题思路图解：
				- ![image.png](../assets/image_1664523891364_0.png)
				- ![image.png](../assets/image_1664524140419_0.png)
				- ![image.png](../assets/image_1664524337458_0.png)
				- ![image.png](../assets/image_1664524611355_0.png)
		- 形式二的理解：
		  collapsed:: true
			- 问题理解：N个0和N个1组成一个数，可以任意组合，但要求任意长度的前缀中0的数量不要比1少，请问这样达标的组合有多少个？
			  collapsed:: true
				- ![image.png](../assets/image_1664525189107_0.png)
				- ![image.png](../assets/image_1664525228302_0.png)
				- ![image.png](../assets/image_1664525316341_0.png)
			- 解题的知识前提：
			  collapsed:: true
				- 整数和偶数的个数是相等的，或者说等势的，因为它们存在对应的一一映射
				  collapsed:: true
					- ![image.png](../assets/image_1664525610081_0.png)
					- ![image.png](../assets/image_1664526093730_0.png)
					  collapsed:: true
						- 旗子的颜色能够一一对应到不同的家族
						- 家族对应的族徽能够一一对应到不同的旗子上面
						- 同一家族对应的族徽和颜色不一定在同一个旗子上，也就是说A家族的族徽对应旗子m，旗子n的颜色对应A家族，m和n不必是同一个旗子
						- A和B集合通过两个现象分别建立了一一映射关系，A和B可能没有任何语义关系，但是它们的大小必然相等
						-
			- 解题思路：
			  collapsed:: true
				- A集合是N个0和N个1组成的非法情况，B集合是（N+1）个1和（N-1）个0组成的所有情况
				  collapsed:: true
					- ![image.png](../assets/image_1664527110124_0.png)
				- A中每个非法元素中都会对应于一个最早的非法前缀，即这个前缀中1的数量恰好比0的数量多1，因为整个数种0和1和元素总数是相同的，所以最早非法前缀对应的最长后缀中则是0的数量刚好比1的数量多1。将A中最长后缀中0和1进行颠倒，即把0变化成1，1变换成0，则整个数中1的数量增加1，0的数量减小1，即有N+1个1，N-1个0，很明显这是集合B中的一个元素。
				  collapsed:: true
					- ![image.png](../assets/image_1664527505477_0.png)
					- ![image.png](../assets/image_1664527949830_0.png)
					- ![image.png](../assets/image_1664527985200_0.png)
					- ![image.png](../assets/image_1664528016226_0.png)
					- ![image.png](../assets/image_1664528072357_0.png)
					- ![image.png](../assets/image_1664528189169_0.png)
					-
				- 可以证明A到B的这种映射关系是一种一一隐射：
					- A中的有两个非法的数：非1和非2。非1的最早非法前缀是a，最长后缀是b；非2的最早非法前缀是c，最长后缀是d。
					  collapsed:: true
						- ![image.png](../assets/image_1664528435017_0.png)
					- 若a = c， 则 b  != d,  b和d映射之后的部分也必然不等；若 a ！= c，因为映射中a和c都不会发生改变，所以隐射之后的两个数不等。
					  collapsed:: true
						- ![image.png](../assets/image_1664528512356_0.png)
				- 由集合论可知，A和B的大小相同
				- N个0和N个1组成的合法情况
				  collapsed:: true
					- = N个0和N个1组成的所有情况 - N个0和N个1组成的非法情况
					- = N个0和N个1组成的所有情况 - |A|
					- = C（2N, N） -  |B|
					- = C(2N, N) - C(2N, N - 1)
					- = C(2N, N) - C(2N, N + 1)
					- 图示：
						- ![image.png](../assets/image_1664537106765_0.png)
				-
			-
			-
		-
	- 应用实例：
	  collapsed:: true
		- 实例1：给定一组数，每个数可以入栈后直接出栈，也可以等其他元素进栈出栈后再出栈，可能的路径数可以使用卡特兰数来解决，因为这个路径要求入栈数必然是大于出栈数的
		  collapsed:: true
			- ![image.png](../assets/image_1664541387372_0.png)
		- 实例2：股票涨跌
		  collapsed:: true
			- 股票上涨次数一定大于下跌次数
				- ![image.png](../assets/image_1664541824472_0.png)
				-
		- 实例3：偶数个人排队
			- 排成两行，后面一行的人的序号一定要比前面人的序号大
				- ![image.png](../assets/image_1664541987730_0.png)
				- ![image.png](../assets/image_1664542134521_0.png)
				-
	- 思维捡漏：
		- A和B不能找到一一隐射，不能说明A和B的大小不等，因为建立隐射往往还是需要一定的语义、或者几何、数值等关系的, 而A和B可能完全无关
		  collapsed:: true
			- ![image.png](../assets/image_1664542517313_0.png)
		- 案例：
			- 一根5米长的绳子上有无数个点，另一根10米长的绳子也有无数个点，下图可知两个绳子上的无数个点能够建立一一隐射关系，所以点数相同；若两根绳子上的点数是有限个，点数必须完全相同才能建立一一映射。
				- ![image.png](../assets/image_1664542839589_0.png)
				- 长度为0的绳子也可能包含无穷多个点：一米的绳子不断划分处前后1/3部分，则每次的长度变成原来的2  /  3，当划分的次数足够多，点的数目趋于无穷，绳子的长度趋于0
					- ![image.png](../assets/image_1664545258478_0.png)
					- ![image.png](../assets/image_1664545304957_0.png)
					- ![image.png](../assets/image_1664545388972_0.png)
					-
-