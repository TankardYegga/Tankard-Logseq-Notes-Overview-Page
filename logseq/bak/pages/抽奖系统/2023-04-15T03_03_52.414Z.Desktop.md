- 项目链接：
  id:: 64351413-3ead-4b40-9a8c-2b223b100323
	- https://gitcode.net/KnowledgePlanet/Lottery/-/wikis/home
	- https://bugstack.cn/md/project/lottery/Part-2/%E7%AC%AC05%E8%8A%82%EF%BC%9A%E6%8A%BD%E5%A5%96%E7%AD%96%E7%95%A5%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91.html
	- [CreativeAlliance / lottery-5215-Tankard · GitCode](https://gitcode.net/CreativeAlliance/lottery-5215-tankard)
	- 提交规范：
		- [文件 · 210814_xfg_strategy · KnowledgePlanet / Lottery · GitCode](https://gitcode.net/KnowledgePlanet/Lottery/-/tree/210814_xfg_strategy)
		- [Lottery/sqls · master · CreativeAlliance / lottery-5215-Tankard · GitCode](https://gitcode.net/CreativeAlliance/lottery-5215-tankard/-/tree/master/Lottery/sqls)
	- 改进：
		- [关于使用扫描方式注册抽奖策略方案 (#54) · Issue · KnowledgePlanet / Lottery · GitCode](https://gitcode.net/KnowledgePlanet/Lottery/-/issues/54)
- [[ProjectIssues]
  id:: 64351412-2165-45f5-83a0-bea12361f875
	- DONE 一直报错xml和mapper对应的接口没有匹配起来：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-26 Sun 07:31:42]--[2023-02-26 Sun 08:45:23] =>  01:13:41
	  :END:
		- ![image.png](../assets/image_1677367670697_0.png)
		- ![image.png](../assets/image_1677367713468_0.png)
		- 问题分析和解决办法：
			- 错误的原因在XML文件，第一个错误是我建的并不是xxx.xml文件，而是xxx文件；二是直接新建的xml文件名与Mapper对应的接口名并不一致（参考[(87条消息) 解决org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)问题_孙大诚_SunRobin的博客-CSDN博客_org.apache.ibatis.binding](https://blog.csdn.net/sundacheng1989/article/details/81630370)）。在我把Activity_Mapper重命名为IActivityDao.xml之后，运行该测试类依旧报了相同的错误，检查后发现此时target目录下里面的Activity_Mapper并没有进行对应的更新，于是按照[(87条消息) IDEA 错误 找不到或无法加载主类（完美解决）_Adam`南帝·梁的博客-CSDN博客_找不到或无法加载主类](https://blog.csdn.net/l_mloveforever/article/details/112725753)将该target目录删除，重新build了整个项目。
			- 这是发现依据会报错“No runnable Method”，这才发现这个error和下面一张图片的报错“Invalid bound statement ”并不是同一个错误原因导致的，这个错误是junit的导包错误导致的：[(87条消息) java.lang.Exception: No runnable methods_孤鸿踏雪的博客-CSDN博客](https://blog.csdn.net/single_wolf_wolf/article/details/106745959)。我导的包是
			  import org.junit.jupiter.api.Test。
			- 还有的一些其他小问题：junit的测试方法必须是以public来修饰的；最好使用MapperScan(basePackages={})的方式来扫描Mapper，同时注意MapperScan里面的参数是目录而不是具体的文件地址
			-
	- DONE 打包整个项目的时候报错：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-26 Sun 09:03:51]
	  CLOCK: [2023-02-26 Sun 09:03:54]--[2023-02-26 Sun 14:16:04] =>  05:12:10
	  :END:
		- ![image.png](../assets/image_1677373464937_0.png)
		- 分析原因和解决办法：
			- 出现了多种类型的错误：
				- 一是在父的pom中已经定义了<groupId>org.example</groupId>和<version>1.0-SNAPSHOT</version>, 那么在所有的子模块中就无需再次定义这两个标签了，因为子模块可以继承这两个，而我在实际的代码中把有些子模块的版本写成了0.0.1-SNAPSHOT, 这样不仅会让整个项目的版本看起来混乱，更容易引发依赖管理的错误；同样在父pom中定义的properties通常也是可以直接在子POM中复用的
				- 二是当前报错的核心原因，就是我的lottery-common的packing方式不是jar而是写成了pom，所以就会出现找不到jar包的这种错误提示了；只有根目录下使用pom的方式进行打包，而其他子模块除了interfaces使用war方式打包以外，都使用jar的打包方式，如果对根目录也就是当前工程使用jar方式打包，则会报错如下：
					- ![image.png](../assets/image_1677392500170_0.png)
				- 三就是得先运行父POM的clean和install，再来运行子POM中的clean和install，如果先直接运行子POM，也会出现上面的这种错误
	- DONE 无法进行rpc通信，报错如下：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-26 Sun 15:37:37]
	  CLOCK: [2023-02-26 Sun 15:37:39]--[2023-02-26 Sun 17:58:22] =>  02:20:43
	  :END:
		- ![image.png](../assets/image_1677397100254_0.png)
		- ![image.png](../assets/image_1677397123802_0.png)
		- Injection of @org.apache.dubbo.config.annotation.Reference dependencies is failed; nested exception is java.lang.IllegalStateException: No such any registry to reference com.example.rpc.IActivityBooth on the consumer 10.192.24.196 use dubbo version 2.7.1, please config <dubbo:registry address="..." /> to your spring config.
		- 解决方法：
			- 必须开启interfaces的启动类运行，同时要在服务方和客户端配置dubbo。
			- 如果使用直连模式：
			  collapsed:: true
				- ![image.png](../assets/image_1677405495074_0.png)
			- 如果使用广播模式：
			  collapsed:: true
				- 无论使用本地ip地址还是localhost，都报错如下，暂时不解决，等学完dubbo再说：
					- ![image.png](../assets/image_1677406027829_0.png)
	- DONE interfaces子模块报错java.lang.IllegalArgumentException:Property ‘sqlSessionFactory‘ or ‘sqlSessionTemplate‘ are required
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-26 Sun 17:45:02]--[2023-02-26 Sun 17:45:40] =>  00:00:38
	  :END:
		- 解决方法：将mybatis-spring-boot-starter的版本从3.0.0切换到2.1.4
	- DONE 报出如下警告，与junit有关
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-26 Sun 17:55:36]--[2023-02-26 Sun 17:57:00] =>  00:01:24
	  :END:
		- ![image.png](../assets/image_1677405338056_0.png)
		- 解决办法：
			- 还是junit导包的问题，参考
				- https://blog.csdn.net/One_L_Star/article/details/103293616
				-
			-
	- StrategyDetail的默认id是String类型的，而不是平常的Long类型；strategyId和activityId的类型是Long, 而不是像awardId是String类型的
	- DONE 注意org和com开头的groupId，不要把两者混淆，造成一下写org一下写com的错误，会引起很多依赖的问题
	  :LOGBOOK:
	  CLOCK: [2023-02-27 Mon 23:17:21]
	  CLOCK: [2023-02-27 Mon 23:17:23]--[2023-02-27 Mon 23:17:54] =>  00:00:31
	  :END:
	- DONE 一直报告使用@Component标记的这个类的Bean找不到
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-27 Mon 23:22:45]
	  CLOCK: [2023-02-27 Mon 23:22:46]--[2023-02-28 Tue 11:02:30] =>  11:39:44
	  :END:
		- ![image.png](../assets/image_1677511387103_0.png)
		- 问题分析和解决方法：
			- 最先开始是只有这个错误，后来为了改正这个错误，不小心将MapperScan里面的org.example又写成了com.example，导致一直无法找到IActivityDao这个Bean；这里是在SpringBoot的启动类必须写上MapperScan，如果只在对应的接口写上了Mapper也是无效的，报错会如图。原因是这里Mapper对应的那些接口类和springboot的启动类并不在一个同一个目录下，也不再启动类的子目录下，所以直接使用Mapper是没办法获取到正确的Mapper文件的路径的。我这里的错误本质上也是路径错误，只不过是把路径的名称也写错了。
			  collapsed:: true
				- ![image.png](../assets/image_1677551687069_0.png)
			- 查阅了[(88条消息) [Spring]在使用@Resource进行属性注入时,IDEA编译器报红线错误[非Maven项目]_臧初之的博客-CSDN博客_idea @resource 报错](https://blog.csdn.net/mmmm0584/article/details/114646721)资料后添加了javax.annotation的依赖，但是发现并不管用
			- 最终解决办法是：在interfaces这个module下的启动类里面写上了ComponentScan注解，之前在测试类上写了这个注解并没有效果，所以需要注意注解所写的位置。这里问题的本质和“无法找到IActivityDao这个Bean”是一样的，都是因为要引用的对象在另一个module中，直接在对应的单独文件上标注@Componet也是无效的，必须显示在当前的启动类中加入扫描的目录
				- ![image.png](../assets/image_1677553343868_0.png)
	- DONE sql语句执行报错
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-28 Tue 10:19:18]
	  CLOCK: [2023-02-28 Tue 10:19:20]--[2023-02-28 Tue 10:40:01] =>  00:20:41
	  :END:
		- ![image.png](../assets/image_1677550764669_0.png)
		- ![image.png](../assets/image_1677551079740_0.png)
		- 在application.yml文件中不能同时写上这两个属性配置，去掉configuration即可
	- DONE 不运行rpc-test时报出了与dubbo相关的错误：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-28 Tue 11:04:12]
	  CLOCK: [2023-02-28 Tue 11:04:14]--[2023-02-28 Tue 11:36:22] =>  00:32:08
	  :END:
		- ![image.png](../assets/image_1677553469780_0.png)
		- ![image.png](../assets/image_1677555285723_0.png)
		- 20880这个端口被占用了：
			- 换用20881，即可解决
			- [(88条消息) 解决com.alibaba.dubbo.rpc.RpcException: Fail to start server(url: dubbo://192.168.194.1:20880/...报错方案_林深见喵的博客-CSDN博客_fail to start server](https://blog.csdn.net/HelloWorld998/article/details/94852083)
			-
	- DONE 无法读取service下的抽奖算法接口
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-28 Tue 11:50:08]
	  CLOCK: [2023-02-28 Tue 11:50:14]
	  CLOCK: [2023-02-28 Tue 11:50:22]--[2023-02-28 Tue 13:23:21] =>  01:32:59
	  :END:
		- ![image.png](../assets/image_1677556209698_0.png)
		- 给IDrawExec的实现类而不是接口本身添加了@Service(name="")的注解
	- DONE sql语句的异常
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-02-28 Tue 13:23:31]
	  CLOCK: [2023-02-28 Tue 15:35:44]
	  CLOCK: [2023-02-28 Tue 15:35:45]--[2023-02-28 Tue 16:10:19] =>  00:34:34
	  :END:
		- ![image.png](../assets/image_1677569749707_0.png)
		- 当没有获奖时，两个算法里面应该返回null值，而不是返回一个字符串，因为这与后面的数据集相关的Dao操作会产生不一致问题，后面的Dao操作都是判断为null，来判断是否获奖。需要保持前后一致：
			- ![image.png](../assets/image_1677571742903_0.png)
				- 改正为return null
			- ![image.png](../assets/image_1677571785692_0.png)
			-
	- DONE @Service到底是什么用途
	  :LOGBOOK:
	  CLOCK: [2023-02-28 Tue 23:56:48]
	  CLOCK: [2023-02-28 Tue 23:56:49]--[2023-03-01 Wed 10:14:06] =>  10:17:17
	  :END:
	- DONE 当没有中奖时，返回的awardId为null，就会报错配送服务的工厂类有空指针异常：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-01 Wed 09:23:45]
	  CLOCK: [2023-03-01 Wed 09:23:46]--[2023-03-01 Wed 10:13:58] =>  00:50:12
	  :END:
		- ![image.png](../assets/image_1677633860422_0.png)
		- 解决方案：
			- 如果awardType为null，就不执行配送服务了
	- DONE docker 报错，一致无法启动
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-01 Wed 22:38:36]
	  CLOCK: [2023-03-01 Wed 22:38:37]--[2023-03-01 Wed 22:39:09] =>  00:00:32
	  :END:
		- 重启电脑就就好了，并没有采用网上的命令法
	- DONE 测试活动分支时的模块之间报错
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-01 Wed 22:39:19]
	  CLOCK: [2023-03-01 Wed 22:40:32]
	  CLOCK: [2023-03-01 Wed 22:40:42]--[2023-03-01 Wed 23:22:58] =>  00:42:16
	  :END:
		- ![image.png](../assets/image_1677681634147_0.png)
		- 产生了循环依赖，在domain中删除对基础层的依赖
	- DONE 当将domain依赖infrastructure转换成infrastructure依赖domain时，出现了很多的相关问题：[[$red]]==一是必须将domain模块中pom对infrastructure的依赖去除，否则会形成循环依赖；二是将domain领域中不同domain下的repository的接口实现类从domain模块移动到了infrastructure中与dao、po同级的子目录repository中，但是接口的定义仍然保存在domain中，这样在interfaces模块的程序启动类中就必须在ComponentScan注解中加上infrastructure/repository的文件夹地址；==三是本次如下的报错了：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-01 Wed 23:51:39]
	  CLOCK: [2023-03-01 Wed 23:51:57]
	  CLOCK: [2023-03-01 Wed 23:52:06]
	  CLOCK: [2023-03-01 Wed 23:52:13]
	  CLOCK: [2023-03-01 Wed 23:53:12]--[2023-03-02 Thu 00:54:52] =>  01:01:40
	  :END:
		- org.springframework.beans.factory.BeanCreationException: [[$red]]==Error creating bean with name 'drawExec': Injection of resource dependencies failed;== nested exception is org.springframework.beans.factory.BeanCreationException: [[$red]]==Error creating bean with name 'strategyRepository':== Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: [[$red]]==Error creating bean with name 'IAwardDao' defined in file== [D:\GraduateProject\java_jobs_preparations\lottery_project\lottery-5215-tankard\Lottery\lottery-infrastructure\target\classes\org\example\infrastructure\dao\IAwardDao.class]: Unsatisfied dependency expressed through bean property 'sqlSessionFactory'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sqlSessionFactory' defined in class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method 'sqlSessionFactory' threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: 'file [D:\GraduateProject\java_jobs_preparations\lottery_project\lottery-5215-tankard\Lottery\lottery-interfaces\target\classes\mybatis\mapper\IActivityDao.xml]'; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is 'file [D:\GraduateProject\java_jobs_preparations\lottery_project\lottery-5215-tankard\Lottery\lottery-interfaces\target\classes\mybatis\mapper\IActivityDao.xml]'. Cause: org.apache.ibatis.builder.BuilderException: Error resolving class. Cause: org.apache.ibatis.type.TypeException: Could not resolve type alias 'org.example.domain.activity.model.vo.AlterStateVO'.  Cause: java.lang.ClassNotFoundException: [[$red]]==Cannot find class:org.example.domain.activity.model.vo.AlterStateVO==
		- [[$green]]==原因分析与解决办法：==
			- 不小心把domain下AlterStateVO写成了AlertStateVO, 所以提示找不到
			- No qualifying bean of type 'org.example.domain.activity.service.deploy.IActivityDeploy' available:
			  collapsed:: true
				- 忘记把domain中的IActivityDeploy的实现类加上@Service注解了，并且需要在interfaces模块的启动类里加上domain下activity的目录文件夹：
					- ![image.png](../assets/image_1677688251814_0.png)
					-
			- 问题来了，为什么会在第一行说名为drawExec的Bean创建失败呢？
				- 这里其实有多个注入的问题，并不是说全部都是因为一个注入失败导致的：
				- 与drawExec无关的注入失败的逻辑是：
					- 原因是这样，nested exception的含义就是更深一层的异常，也就是说程序执行到当前位置出现exception了，如果当前位置的代码是一个方法执行，那么更深一层的异常说的就是方法内部的异常导致的。也就是说，当前位置只是异常暴露出来的最直接最外面的位置，但是真正导致异常的原因，是由于java中的继承、接口实现等机制导致的，更上层的异常。
					- 这里因为IActivityDao.xml这个mapper的parameterType的全限定路径写错了，导致IActivityDao activityDao的资源注入会失败，而org.example.interfaces.test.APiTest中恰恰对该资源进行了注入，所以该测试函数必然报错；
				- 与drawExec有关的注入失败的逻辑是：
					- "drawExec"对应的是IDrawExec接口的实现类DrawExecImpl，而该实现类继承了AbstractDrawBase这个抽象类，继续向上也继承了DrawStrategySupport这个类，而该类中显示用到了对IStrategyRepository资源的注入，而IStrategyRepository的实现类StrategyRepository被放在了infrastructure下的repository类中了，所以必须要显示将该repository的文件夹路径加入启动类的ComponentScan的扫描范围内才行：
						- ![image.png](../assets/image_1677689657428_0.png)
						- ![image.png](../assets/image_1677689682621_0.png)
		-
			-
	- DONE 出现了jdbc的未被分类的SQL异常：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-02 Thu 09:33:38]--[2023-03-02 Thu 10:29:33] =>  00:55:55
	  :END:
		- ![image.png](../assets/image_1677720819692_0.png){:height 368, :width 716}
		- ![image.png](../assets/image_1677723289453_0.png)
		- 发现原因在数据组表的字符编码问题，没有注意到sql里面的字符串字段写的编码是：CHARACTER SET latin1, 而latin1是mysql的默认字符集ISO-8859-1，而ISO-8859-1编码是单字节编码，向下兼容ASCII。不支持中文编码，如果你在创建数据库或建表时没有明确指定编码的方式，那么数据库将采用默认的编码方式，而后你在插入中文的数据时将会出现乱码
	- DONE There is no getter for property named 'strategyDesc' in 'class org.example.infrastructure.po.Strategy'
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-02 Thu 10:29:41]
	  CLOCK: [2023-03-02 Thu 10:29:58]--[2023-03-02 Thu 10:37:14] =>  00:07:16
	  :END:
		- ![image.png](../assets/image_1677724199578_0.png)
		- 对应的类中忘记添加该属性以及对应的setter和getter了，在mapper的xml文件里如果缺乏getter的话，应该就没办法获取#{VaribleName}的值了
	- DONE IdContext里报告Snowflake等都无法被自动装配
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-02 Thu 15:10:19]--[2023-03-02 Thu 15:11:38] =>  00:01:19
	  :END:
		- 在interfaces启动类的componentscan里加上support这个domain的路径
	- DONE  遇到mybatis自动配置的错误，
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-03 Fri 19:59:25]
	  CLOCK: [2023-03-03 Fri 19:59:29]--[2023-03-03 Fri 22:07:37] =>  02:08:08
	  :END:
		- Error creating bean with name 'org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration': Bean instantiation via constructor failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$87d17034]: Constructor threw exception; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cn.bugstack.middleware.db.router.config.DataSourceAutoConfig': Initialization of bean failed; nested exception is java.lang.NumberFormatException: null
		- 问题分析与解决方案：
			- 在interfaces下的application.yml中配置了多路数据源的路由配制后自动消失
	- DONE 报错多路数据源的路由配置存在问题
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-03 Fri 21:56:34]
	  CLOCK: [2023-03-03 Fri 21:56:36]--[2023-03-03 Fri 22:01:06] =>  00:04:30
	  :END:
		- ![image.png](../assets/image_1677851809500_0.png)
		- 重新复制了参考代码中的yml配置，该错误就消失了，不清楚原来的yml哪里写错了
	- DONE 报告uuid不存在对应的getter
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-03 Fri 22:07:45]
	  CLOCK: [2023-03-03 Fri 22:07:47]--[2023-03-03 Fri 22:09:10] =>  00:01:23
	  :END:
		- xml文件中sql语句中将uuid改成uuId即可，因为我写的代码里面防重复的成员变量是uuId, 不是参考代码里的uuid, 但是我的代码里的xml是直接从参考代码里拷贝过来的，所以忘记修改了
	- DONE 用户策略导出的测试类报错sql执行的问题：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-03 Fri 22:10:35]
	  CLOCK: [2023-03-03 Fri 22:10:38]--[2023-03-03 Fri 22:14:33] =>  00:03:55
	  :END:
		- org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): org.example.infrastructure.dao.IUserStrategyExportDao.queryUserStrategyExportByUId
		- 问题分析和解决方案：
			- ![image.png](../assets/image_1677852847409_0.png)
				- 参考[(91条消息) Invalid bound statement (not found)出现原因和解决方法_陈大豆的博客-CSDN博客](https://blog.csdn.net/weixin_44695793/article/details/107752054)可知，namespace写错了
				-
	- DONE 插入用户策略数据时报了一个空指针的错误
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-03 Fri 22:17:19]
	  CLOCK: [2023-03-03 Fri 22:17:20]--[2023-03-03 Fri 22:30:26] =>  00:13:06
	  :END:
		- ![image.png](../assets/image_1677853054184_0.png)
		- 找出来空指针的位置如下：
			- ![image.png](../assets/image_1677853773524_0.png)
			- 原因是我在Constants写了Snowflake和SnowFlake两个枚举量，但是map中只注册了Snowflake
	- DONE 为啥有些数据库操作是判断是否等于1来决定sql语句是否成功
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-04 Sat 16:45:37]
	  CLOCK: [2023-03-04 Sat 16:45:39]--[2023-03-04 Sat 16:46:38] =>  00:00:59
	  :END:
		- 应该是成功插入或者删除一行，就会返回1；如果成功插入或者删除n行，就会返回n
	- DONE 比较的时候可能为null的值应该要进行处理
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-05 Sun 00:06:53]
	  CLOCK: [2023-03-05 Sun 00:06:55]
	  CLOCK: [2023-03-05 Sun 00:06:59]--[2023-03-05 Sun 00:14:59] =>  00:08:00
	  :END:
		- 报错的代码：req获取到日期为null，于是下面的代码变成了 null.before(x)
		  collapsed:: true
			- ![image.png](../assets/image_1677946043536_0.png)
		- 解决方案：
			- 除了可以先进行null值判断，再来进行时间比较，也可以在初始化时就保证Partake的日期不回会null：
				- ![image.png](../assets/image_1677946472097_0.png)
				- ![image.png](../assets/image_1677946497188_0.png)
				-
	- DONE 报告mybatis绑定xml相关的错误，但是检查了很久都觉得绑定的没有错误
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-06 Mon 23:39:24]
	  CLOCK: [2023-03-06 Mon 23:39:26]--[2023-03-06 Mon 23:45:22] =>  00:05:56
	  :END:
		- org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): org.example.infrastructure.dao.IRuleTreeDao.queryRuleTreeByTreeId
			- xml中namespace写错了，因为IRuleTreeDao和IRuleTreeNodeDao名字很像，所以误以为写对了
	- DONE 数据库中的关键字和基础层里po文件夹下的实体类的属性不一致，导致mybatis报告反射相关的错误
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-06 Mon 23:47:44]
	  CLOCK: [2023-03-06 Mon 23:47:45]--[2023-03-06 Mon 23:49:24] =>  00:01:39
	  :END:
		- ![image.png](../assets/image_1678117704948_0.png)
		- 我原先写的属性是createDate, 而数据库里面是createTime，更改实体类要更快速一点
	- DONE 给整个项目package出现错误：org.example.rpc.dto.AwardDTO does not have an accessible parameterless constructor.
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 14:33:00]
	  CLOCK: [2023-03-07 Tue 14:33:01]--[2023-03-07 Tue 14:53:42] =>  00:20:41
	  :END:
		- 更换mapstruct的版本为1.4.1.Final就没有出现该错误了
	- DONE mapstruct使用之后测试代码报了一个超长的错误：
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 14:41:10]
	  CLOCK: [2023-03-07 Tue 14:41:12]--[2023-03-07 Tue 14:53:10] =>  00:11:58
	  :END:
		- java: Internal error in the mapping processor: java.lang.NullPointerException  	at org.mapstruct.ap.internal.processor.DefaultVersionInformation.createManifestUrl(DefaultVersionInformation.java:182)  	at org.mapstruct.ap.internal.processor.DefaultVersionInformation.openManifest(DefaultVersionInformation.java:153)  	at org.mapstruct.ap.internal.processor.DefaultVersionInformation.getLibraryName(DefaultVersionInformation.java:129)  	at org.mapstruct.ap.internal.processor.DefaultVersionInformation.getCompiler(DefaultVersionInformation.java:122)  	at org.mapstruct.ap.internal.processor.DefaultVersionInformation.fromProcessingEnvironment(DefaultVersionInformation.java:95)  	at org.mapstruct.ap.internal.processor.DefaultModelElementProcessorContext.<init>
		- [(91条消息) mapstruct坑：Internal error in the mapping processor: java.lang.NullPointerException at org.mapstruct._mapstruct的坑_Gangbb的博客-CSDN博客](https://blog.csdn.net/qq_37132495/article/details/122010257)
	- DONE IMAPPING 无法被找到
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 14:53:47]
	  CLOCK: [2023-03-07 Tue 14:59:38]--[2023-03-07 Tue 15:01:23] =>  00:01:45
	  :END:
		- ![image.png](../assets/image_1678172382725_0.png)
		- ![image.png](../assets/image_1678172457712_0.png)
		- 不要只用facade这个子目录就行
	- DONE 测试数据是正确的，但是整个领奖活动在规则引擎处就报失败了
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 16:18:00]
	  CLOCK: [2023-03-07 Tue 16:18:02]
	  CLOCK: [2023-03-07 Tue 16:18:04]--[2023-03-07 Tue 16:22:32] =>  00:04:28
	  :END:
		- 经过核查之后发现，规则引擎的执行过程并没有任何问题，其成功地执行了并返回了过滤后的活动号100001L。真正错误的原因是EngineResult里的isSuccess我们没有在构造函数里面显示赋值为true，导致虽然执行成功了，isSuccesss还是false，导致后面的if判断逻辑认为规则引擎执行失败了。对构造函数进行修改，问题得到解决。
			- ![image.png](../assets/image_1678177328417_0.png)
			-
	- DONE 数据库里的10000L活动明明是有对应的策略编号的，但是我们的dao接口却并没有查询出来
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 16:22:41]
	  CLOCK: [2023-03-07 Tue 16:22:43]--[2023-03-07 Tue 16:39:40] =>  00:16:57
	  :END:
		- ![image.png](../assets/image_1678177464763_0.png)
		- ![image.png](../assets/image_1678177500911_0.png)
		- 这导致了我们使用到活动查询功能的其他地方也会连带出现错误，比如查询活动账单这个地方：
		  collapsed:: true
			- ![image.png](../assets/image_1678177631605_0.png)
			-
		- 问题分析：
			- 查看了xml文件发现其返回类型少了策略ID的字段，尽管其select语句里面是有的
			  collapsed:: true
				- ![image.png](../assets/image_1678177783648_0.png)
				- ![image.png](../assets/image_1678177803582_0.png)
				-
		- 解决办法：
			- 增加上对应的字段即可
			- 可以发现除了strategyId, stock_surplus_count字段也忘记添加上了
				- ![image.png](../assets/image_1678178375819_0.png)
	- DONE Partake默认创建时间为现在，导致和数据库中的日期比较时，始终是当前时间不在活动举办范围内
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 16:49:24]
	  CLOCK: [2023-03-07 Tue 16:49:25]--[2023-03-07 Tue 16:51:15] =>  00:01:50
	  :END:
		- 报错原因：
		  collapsed:: true
			- ![image.png](../assets/image_1678179048436_0.png)
		- 解决办法：
		  collapsed:: true
			- 直接把领取活动函数中检验活动日期的部分给注释掉即可
		-
		-
	- DONE 从库存中扣减活动失败，mybatis报相关错误
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 16:56:34]
	  CLOCK: [2023-03-07 Tue 16:56:35]--[2023-03-07 Tue 17:07:23] =>  00:10:48
	  :END:
		- ![image.png](../assets/image_1678179408303_0.png)
		- 问题分析：
			- partakeResult里面的策略编号为null，而该策略编号写得是：partakeResult.getStrategyId()。这是一个非常愚蠢的错误，给自己设置从自己身上获取的值
		- 解决方案：
			- ![image.png](../assets/image_1678179964348_0.png)
		- DONE 抽奖的initRateTuple和AbstractDrawBase里面的checkAndInitRateData的方法逻辑写错了
		  :LOGBOOK:
		  CLOCK: [2023-03-07 Tue 17:53:00]
		  CLOCK: [2023-03-07 Tue 17:53:01]--[2023-03-07 Tue 17:55:53] =>  00:02:52
		  :END:
			- ![image.png](../assets/image_1678182864178_0.png)
				- 特别是上面这段顺序，我把上面的1和2的先后写反了，导致抽奖模式是总体概率是，awardRateInfoMap根本就是null
	- DONE Send failed; nested exception is org.apache.kafka.common.errors.TimeoutException: Topic Kafka-World not present in metadata after 60000 ms
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 22:32:12]--[2023-03-07 Tue 23:15:25] =>  00:43:13
	  :END:
		- 必须要在本地通过命令行启动zookeeper、kafka、create topic才行，然后再运行测试程序，测试程序只是起到生产者的目的
			- [(91条消息) Win10下kafka简单安装及使用_github_38482082的博客-CSDN博客](https://blog.csdn.net/github_38482082/article/details/82112641)
		- 后面还报了其他错，是因为application.yml中的kafka配置信息的问题 我每回都照着手敲一遍 结果都运行不出来，但是一复制yml文件就好了
	- DONE xxl-job的执行器一直报告执行失败，原因是执行器的地址为空，但是在xxl-job的源码里面报告的是email相关的配置有问题
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-04-08 Sat 00:23:49]
	  CLOCK: [2023-04-08 Sat 00:25:07]--[2023-04-08 Sat 15:20:49] =>  14:55:42
	  :END:
		- ![image.png](../assets/image_1680884668472_0.png){:height 349, :width 716}
		- 我自己的手机号有问题，找别人的手机号一发短信配置qq邮箱立马解决了
	- DONE xxl-job报错JDBC connection
	  :LOGBOOK:
	  CLOCK: [2023-04-08 Sat 15:21:58]--[2023-04-08 Sat 15:21:59] =>  00:00:01
	  :END:
		- 没有启动对应的docker中的mysql实例
	- DONE 我的应用程序报错
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-04-08 Sat 15:24:15]--[2023-04-09 Sun 14:41:09] =>  23:16:54
	  :END:
		- Failed to load project configuration: cannot parse file D:\GraduateProject\java_jobs_preparations\lottery_project\lottery-5215-tankard\Lottery\.idea\artifacts\interfaces_war_exploded.xml: Unexpected character '<' (code 60); expected a name start character
		   at [row,col {unknown-source}]: [93,3]
		- git merge失败导致的，需要使用git reset --hard回退版本
	- DONE dubbo配置错误，并不清楚在application.properties里面配置xxl-job的执行器时是否需要配置dubbo，因为我感觉xxl-job是属于RPC服务的一种？感觉这一块根本没有学会
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-04-09 Sun 14:41:16]
	  CLOCK: [2023-04-09 Sun 14:41:20]--[2023-04-09 Sun 16:49:21] =>  02:08:01
	  :END:
		- java.lang.IllegalArgumentException: Invalid multicast address /10.192.39.194, ipv6 multicast address must start with ff, for example: ff01::1
		- 先尝试下不配置看看是否能够成功允许吧：因为在xxl-springboot-samples中发现其执行器的配置中并没有包含dubbo的配置，但是能在执行器创建时自动注册，且能够运行对应的task，所以并不需要配置dubbo
	- DONE 小付哥的微服务项目中适中无法让执行器自动注册而获取对应的Online地址，且运行的job一直失败报错：执行器地址为null
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-04-09 Sun 16:49:29]
	  CLOCK: [2023-04-09 Sun 16:49:32]--[2023-04-09 Sun 16:55:11] =>  00:05:39
	  :END:
		- 后来找到原因：
			- 一是在interfaces目录下的application.yml文件中的xxl.job.admin.adresses的值中写错了端口号
			- 二是在interfaces的启动类里面并没有把application.woker这个文件夹包含在ComponentScan中，导致对应的Job没有办法被扫描到
		-
	- DONE job的执行结果一直失败
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-04-09 Sun 17:10:10]
	  CLOCK: [2023-04-09 Sun 17:10:15]--[2023-04-09 Sun 17:36:52] =>  00:26:37
	  :END:
		- ![image.png](../assets/image_1681031420206_0.png)
		- 活动mapper中扫描待处理活动的返回值类型应该是ActivityVO而不是Activity
			- ![image.png](../assets/image_1681033009972_0.png)
			-
	- DONE 执行lotteryInvoiceMqStateJobHandler时返回结果报错
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-04-10 Mon 15:48:34]
	  CLOCK: [2023-04-10 Mon 15:48:44]--[2023-04-10 Mon 19:33:09] =>  03:44:25
	  :END:
		- 报错内容：
		  collapsed:: true
			- ![image.png](../assets/image_1681112993934_0.png)
		- 原因所在：
		  collapsed:: true
			- ![image.png](../assets/image_1681112964148_0.png)
		- 解决办法：
			- 下面这个函数是不需要加上@DBRouter注解的。如果加上了之后得到的dbTouter的key将会是空的，但是会自动使用默认的路由配置（也就是用户ID），所以也不会报错；真正的问题是jp.getArgs()此时获取的将是null，jp是ProceedingJointPoint，也就是说从这个连接点的方法处获得方法的参数，但是很明显这个方法的参数为空；而当不使用这个@DBRouter注解时，并不会使用到db-router-spring-boot-starter里面对注解的解析方法，所以程序根本运行不到此时报错的地方里来，自然也不回报错。那么此时的分库分表是怎么实现的呢？实际上是获取了IDBRouterStrategy接口的实现类DBRouterStrategyHashCode的单例Bean对象，通过其来设置数据库路由缓存里面的数据库序号和数据库表的序号，而数据库编号和数据库表的编号是通过外层的循环来设定的。
			- ![90825bef730b2618ea815a1e88955d2.png](../assets/90825bef730b2618ea815a1e88955d2_1681115247805_0.png)
			- ![image.png](../assets/image_1681125525306_0.png)
	- DONE kafka报错
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-04-10 Mon 16:27:11]
	  CLOCK: [2023-04-10 Mon 16:27:14]--[2023-04-10 Mon 21:04:19] =>  04:37:05
	  :END:
		- 16:26:46.516 logback [xxl-job, JobThread-11-1681114965088] ERROR o.s.k.s.LoggingProducerListener - Exception thrown when sending a message with key='null' and payload='{"awardContent":"Code","awardId":"3","awardName":"ipad","awardType":1,"orderId":1454347265400504320,...' to topic lottery_invoice:
		  org.apache.kafka.common.errors.TimeoutException: Topic lottery_invoice not present in metadata after 60000 ms.
		- 17:59:07.203 logback [xxl-job, JobThread-11-1681120585073] ERROR o.s.k.s.LoggingProducerListener - Exception thrown when sending a message with key='null' and payload='{"awardContent":"Code","awardId":"3","awardName":"ipad","awardType":1,"orderId":1454347265400504320,...' to topic lottery_invoice:
		  org.apache.kafka.common.errors.TimeoutException: Topic lottery_invoice not present in metadata after 60000 ms.
		- 启动kafka的cmd命令错误，必须要以下面这个链接中的点开头的方式才行，不然cmd运行命令后不久就自动关闭了（即使设置-daemon也一样），而以点开头，即使不设置-daemon也是一样的
			- https://blog.csdn.net/qq_39654841/article/details/122921485
	- DONE IUserExportDao接口获取的数据
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-04-10 Mon 21:07:04]--[2023-04-10 Mon 22:32:02] =>  01:24:58
	  :END:
		- ![image.png](../assets/image_1681132312781_0.png)
		- mapper中sql语句漏掉了很多关键字段，导致获取的java对象中对应字段为null
- [[Summary]]
  collapsed:: true
  :LOGBOOK:
  CLOCK: [2023-03-01 Wed 10:14:10]
  CLOCK: [2023-03-01 Wed 10:14:12]
  :END:
	- DOING 总结一下项目中ID设置的类型和数量的原因
	  :LOGBOOK:
	  CLOCK: [2023-03-01 Wed 10:14:26]
	  CLOCK: [2023-03-01 Wed 10:14:28]
	  :END:
	- DOING 总结一下所用到的设计模式
	  :LOGBOOK:
	  CLOCK: [2023-03-01 Wed 10:16:02]
	  CLOCK: [2023-03-01 Wed 10:16:04]
	  :END:
	- DOING 思考清楚这里的外键是怎么发挥作用的
	  :LOGBOOK:
	  CLOCK: [2023-03-02 Thu 09:44:38]
	  CLOCK: [2023-03-02 Thu 09:44:39]
	  :END:
	- DONE 总结一下中间件的开发过程和mysql拦截器
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2023-03-03 Fri 22:19:07]
	  CLOCK: [2023-03-03 Fri 22:19:09]--[2023-03-04 Sat 16:45:29] =>  18:26:20
	  :END:
		- 注意一下DBRouterJointPoint这个方法
		  :LOGBOOK:
		  CLOCK: [2023-03-07 Tue 18:08:04]
		  :END:
		- [数据库路由选择中间件搭建 | BanTanger's Blog](https://www.bantanger.tk/pages/1164c2/#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)
		- ![image.png](../assets/image_1677861059795_0.png)
		- ![image.png](../assets/image_1677861414468_0.png)
		-
		-
	- DOING 区分清楚到底是用数据库的自增id还是使用生成器生成的id
	  :LOGBOOK:
	  CLOCK: [2023-03-06 Mon 23:57:15]
	  CLOCK: [2023-03-06 Mon 23:57:16]
	  :END:
	- :LOGBOOK:
	  CLOCK: [2023-03-07 Tue 18:07:44]
	  CLOCK: [2023-03-07 Tue 18:07:45]
	  :END:
- [[面试]]
	- https://bugstack.cn/md/zsxq/material/interview.html
	- DDD架构中domain层中的VO和infrastructure层中的PO有什么区别？
	  collapsed:: true
		- 含义不同：
			- PO 是 Persistent Object 持久化对象，是直接跟数据库打交道的Java Bean或者说model/entity，除了私有的成员变量以外，就只有对应的get和set方法，其成员变量的名称一般和数据库的列保持一致；
			- VO 是 Value Object 值对象，除了跟PO一样的变量、get和set方法以外还可以有其他的变量，但是不用跟数据库打交道，可以把VO理解为是一种无状态的对象。
		- 生命周期不同：
			- VO的生命周期较短，一般只在业务逻辑的处理流程中使用，不会在跨操作中进行数据共享；PO的生命周期较长，会在多次请求和响应之间保持一致的状态，方便检索和存储
		- 可变性不同：
			- VO一旦创建通常就是不可变的，这使得VO的稳定性较强，保持了系统的正确性和稳定性；
			- PO是可变的，其属性和方法会随着数据库结构的改变而进行动态的相应调整，以便数据的存储和检索
	- DDD架构和MVC架构的区别，简单地来说一下？从项目结构的角度来具体说说它们的区别有哪些呢?
	  collapsed:: true
		- MVC更偏向于数据建模，由数据调用驱动，所以其引申出的DAO、PO、VO类都会随着业务开发而不断膨胀，不利于迭代和拓展；
		- DDD架构 将业务流程建模为领域服务，每个领域包括model、仓储服务、服务实现，同时也更加注重运用设计模式
		- https://t.zsxq.com/0dagxEHEP
		  collapsed:: true
			- 按照DDD架构各个层次之间的调用层次来说明一下两种架构的区别。这个调用链就是：interfaces接口层 -》application应用层 =》domain层 =》infrastructure基础服务层。
				- 接口层的功能与MVC中的Controller功能部分类似，都是接受来自用户的请求比如restful请求，然后处理用户请求并将处理结果返回给用户。但是DDD中的接口层只接受请求的参数，然后将参数传递给应用层，应用层处理得到结果后再根据用户的需求进行组装，所以这样的接口相对来说更加隐蔽
				- 应用层负责服务的组装、编排和转发，用于确定业务用例的执行顺序和接口的组装。应用层类似于Controller和Service之间的某层，在抽奖系统中应用层负责组装一个服务模块中各个小服务的执行顺序，比如活动领取、执行抽奖、抽奖结果落库、发送MQ消息触发发奖过程等各个步骤。应用层中同时也可以放置一些权限判断。
				- 领域层是DDD架构的核心。
					- 领域是指有明确边界的范围，定义了要解决的问题的范围，也就是说哪些问题要在该范围内解决，哪些问题不在该范围内解决；领域描述了与其他业务域的关系和协作方式，从而可以解决更系统更复杂的问题。抽奖系统中包含抽奖策略领域、活动领域、奖品领域、规则领域等
					- 领域模块的设计：
						- 要求各个领域之间的依赖关系尽可能少
						- 每个领域模块下都包含model、repository、service三个子模块， 分别负责领域模型、持久化和业务逻辑：
							- model主要封装领域模型中的实体、值对象和聚合根等概念并实现相应的逻辑: 实体Entity具有唯一的标识符，具有一些属性和行为；而值对象没有标识符，同样具有一些属性和行为; 聚合根(Aggregate Root) 是一组相关实体和值对象的集合，同时具有唯一的根实体来保证聚合根内部的一致性和完整性；Domain Event指的是处理领域对象之间交互和协作的事件；服务是与领域对象相关的操作
							- repository负责将领域中的实体和值对象持久化到数据库中，方便后续的检索，包含接口和实现类，主要是一些CRUD的定义
							- service中也定义了业务逻辑的接口和实现类，主要是对领域对象的操作规则
						- 领域层的repository和dao层的区别：repository只关心请求值和返回值，不关心操作数据库的细节，真正实现了只关注业务逻辑
					- 基础层：基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础服务。相比于MVC中的dao层，其多了很多操作，需要承接来自领域层的参数，又要依据需要返回的结构进行相应组装
	- DDD架构的infrastructure的各个子目录是什么样的？
	  collapsed:: true
		- 基础层的子目录可以分别对应不同的基础设施，
			- data子目录对于数据访问相关的代码，如数据访问、数据迁移等
			- logging子目录对应日志记录相关的代码，如日志格式化、日志的重定向等
			- messaging子目录对应消息队列相关的代码，比如消息生产者、消息消费者等
			- security存放安全相关的代码，如用户认证、权限控制等
			- caching是缓存相关的代码，如分布式缓存、内存缓存等
			- utilities中存放通用的工具类相关的代码，如日期格式化、加密和解密等
		- 在抽奖系统，基础层只有数据库和redis缓存这两类基础设施:
			- 数据库包括dao、po和repository层，dao层中定义了与po中实体相关的操作，repository中的功能是对dao层功能的一些组合以及需要一些预处理和后处理
	- infrastructure和domain层的依赖反转要怎么去理解（是什么以及如何实现的）？这种依赖反转对于系统开发有什么好处？谈谈你是如何理解依赖注入的？
	  collapsed:: true
		- 一般来说是domain层会依赖于infrastructure层的基础服务，包括数据库、缓存等，依赖反转就是infrastructure层反过来依赖domain层；具体来说，domain中repository子模块的接口仍然保留，但是把接口的实现放到基础层当中，这样一来基础层只向领域层提供了基本的抽象接口，而屏蔽了自身的实现细节，从而实现了解耦。
		- 基础层和领域层之间的依赖反转是通过依赖注入来实现的，领域层中的service会需要调用repository接口中定义的方法，通过依赖注入获得了基础层中repository接口的实现类；而respository接口的实现类中对功能的实现，其实依赖于dao接口中定义的数据查询和更新操作，dao接口是通过接口层中的mybatis mapper文件来具体执行的。
		- 这种依赖反转使得同一个接口可以动态替换不同的实现类，使得系统具有更多的灵活性和可拓展性。
		- 依赖注入依赖于容器，容器会自动化创建和初始化对象，然后把这些对象注入到需要到它们的地方，从而实现依赖注入的过程。
	- MVC中的M、V、C在代码层面分别对应什么？如何理解Service层？如何理解Servlet层？
	  collapsed:: true
		- Model指的是表示数据和处理数据的部分，通常包括实体类、数据访问对象(Data Access Object)和业务逻辑层（Service层);  View指的是展示数据且与用户交互的部分，包括前端的html、css、javascript等；Controller层指的是应用程序中用于处理用户请求、调用业务逻辑和选择合适的视图显示数据的部分，对应后端的Servlet、Struts和SpringMVC代码；
		- service层是业务逻辑的抽象层，其可以通过调用Dao层的相关方法来实现较为复杂的业务逻辑，同时其向控制层提供服务，将业务的处理结果返回给控制层，然后控制层将数据渲染到视图上。service层是对业务层的进一步分层，实现了业务逻辑和控制层的解耦
	- 用一段话来描述一下你的项目？
	  collapsed:: true
		- 抽奖系统是一个与后台管理系统类似的具有一定通用性的功能系统，可以应用于电商、外卖、出行等多种场景，可以促活、留存和拉新。本系统使用DDD模式作为系统架构进行开发，主要包含应用层、通用层、领域层、基础设施层、接口层和RPC层共六层。基础设施层主要是与数据库层打交道，包括Dao层、PO可持久化对象等；领域层主要是包含规则引擎、抽奖策略、奖品发放等领域服务；通用层定义一些共同的常量和方法；应用层是对领域服务进行组合和编排，构建相应的业务流程；接口层是系统启动类所在的模块，主要是处理用户请求，并将信息传递到应用层；rpc层定义一些远程服务的接口，通过对应用层的调用来进行实现。核心工作是分库分表中间件的开发、领域服务的业务功能实现、规则过滤组件的使用。
		- 分库分表中间件的实现：首先是自定义了两个注解，一个是分库注解，需要指定路由键，另外一个是分表注解，需要指定是否需要分表；分库分表的逻辑在切面类进行实现，首先获取到路由字段的值，然后利用 扰动函数 + 哈希桶数组 的方式 来计算对应的数据库id和表Id，并将 库的ID和表的ID 存放在ThreadLocal类型的缓存当中，这个缓存也被称作数据库上下文；分库逻辑在动态数据源类中进行实现，这个类实现了Spring内置的AbstractRoutingDataSource接口，其使用数据库上下文中的库ID来切换数据源；而分表逻辑主要利用了实现Interceptor接口的拦截器，先是通过反射机制获取到sql语句，然后通过模式匹配来找到表名，然后用数据库上下文中的表Id来修改表名。
		- 规则过滤器的实现：核心是三个类，第一个类是树，包含树的ID、树的名称和树根节点，第二个类是树上的普通节点，包括对应的树的ID、节点本身的ID、节点的类型和值（如果节点是茎结点，就没有值，如果是结果节点，那么就有决策者）、节点对应的规则类型和规则描述（规则类型就是这个决策树某次决策的关键字），第三个类就是节点线类，可以理解为决策树中父子节点所组成的一个决策关系，包含起始节点、目标结点、对应的限定符合（大于小于和等于）、对应的限定值。本系统中是按照用户的信息来决策使用何种抽奖活动，决策的过程是依据信息不断从根节点找到下一个结点，直到这个节点是结果节点，就返回对应的决策值。
	- 为什么需要使用分库分表？分库分表的垂直拆分和水平拆分分别是什么？
	  collapsed:: true
		- 当业务体量大，数据增长很快时，必须把数据分散到不同的数据库不同的表格当中去，以减轻数据库的压力
		- 分库分表的垂直拆分指的是按照业务将不同的表进行分类，放到不同的数据库中去，最终一个数据库对应着很多表，每个表对应一个业务，也就是所谓的专库专用；水平拆分是指当垂直拆分后遇到单机瓶颈时，将同一张表分散到不同的数据库中去，比如user_001, user_002
	- 什么时候分库？什么时候分表？
	  collapsed:: true
		- 当数据库的读写访问量过高，需要更多的数据连接时，需要增加数据库实例来获取更多的数据库连接，提升并发量，这时候需要进行分库；
		- 当单表的数据存储量过大，比如达到千万级别，这时候B+树通常就需要四层了，数据查询速度明显变慢，如果此时并发量不高且数据库连接够用，那么这时候只用进行分表不分库，目的是将单张的数据分散开，提升读写效率；
	- 分库分表中间件的原理和实现过程讲一下？
	  collapsed:: true
		- https://t.zsxq.com/0duaX6mkE {{video https://www.bilibili.com/video/BV1Gm4y1m7Qp/?vd_source=f420feddc90c88f1b9b9f8da3fc2194b}}
			- 自定义了两个注解：DBRouter用于进行分库操作，key表示进行哈希计算的字段，DBRouterStrategy用于进行分表操作，splitTable表示是否需要进行分表；DBRouter注解和DBRouterStratey注解都是作用在基础层的dao层中，DBrouter写在方法上，而DBRouterStrategy写在接口名称上
			  collapsed:: true
				- ```
				  @Documented
				  @Retention(RetentionPolicy.RUNTIME)
				  @Target({ElementType.TYPE, ElementType.METHOD})
				  public @interface DBRouter {
				  
				      /** 分库字段 */
				      String key() default "";
				  
				  }
				  
				  @Documented
				  @Retention(RetentionPolicy.RUNTIME)
				  @Target({ElementType.TYPE, ElementType.METHOD})
				  public @interface DBRouterStrategy {
				  
				      boolean splitTable() default false;
				  
				  }
				  
				  
				  @Mapper
				  @DBRouterStrategy(splitTable = true)
				  public interface IUserStrategyExportDao {
				  
				      /**
				       * 新增数据
				       * @param userStrategyExport 用户策略
				       */
				      @DBRouter(key = "uId")
				      void insert(UserStrategyExport userStrategyExport);
				  
				      /**
				       * 查询数据
				       * @param uId 用户ID
				       * @return 用户策略
				       */
				      @DBRouter
				      UserStrategyExport queryUserStrategyExportByUId(String uId);
				  
				      /**
				       * 更新发奖状态
				       * @param userStrategyExport 发奖信息
				       */
				      @DBRouter
				      void updateUserAwardState(UserStrategyExport userStrategyExport);
				  
				      /**
				       * 更新发送MQ状态
				       * @param userStrategyExport 发送消息
				       */
				      @DBRouter
				      void updateInvoiceMqState(UserStrategyExport userStrategyExport);
				  
				      /**
				       * 扫描发货单 MQ 状态，把未发送 MQ 的单子扫描出来，做补偿
				       *
				       * @return 发货单
				       */
				      List<UserStrategyExport> scanInvoiceMqState();
				  
				  }
				  ```
			- DataSourceAutoConfig是用来自动注入相关信息的：
				- 其实现了EnvironmentAware接口, 而EnvironmentAware包含一个设置环境的方法需要被实现类实现，在具体实现中其是用来读取接口层中resources下的application.yml中路由配置的相关字段的（包括数据库数目、表的数目、路由关键字（如果没有显示配置，则会使用application.yml中默认的uId）、同时结合工具类PropertyUtil来读取不同数据库的信息, 每个数据库的信息由一个包含driver-class-name、url、urlname、password这四个key的哈希Map来表示）；
				  collapsed:: true
					- ```
					  public interface EnvironmentAware extends Aware {
					      void setEnvironment(Environment var	1);
					  }
					  ```
					- ```
					   @Configuration
					  public class DataSourceAutoConfig implements EnvironmentAware {
					  
					    @Override
					      public void setEnvironment(Environment environment) {
					          String prefix = "mini-db-router.jdbc.datasource.";
					  
					          dbCount = Integer.valueOf(environment.getProperty(prefix + "dbCount"));
					          tbCount = Integer.valueOf(environment.getProperty(prefix + "tbCount"));
					          routerKey = environment.getProperty(prefix + "routerKey");
					  
					          // 分库分表数据源
					          String dataSources = environment.getProperty(prefix + "list");
					          assert dataSources != null;
					          for (String dbInfo : dataSources.split(",")) {
					              Map<String, Object> dataSourceProps = PropertyUtil.handle(environment, prefix + dbInfo, Map.class);
					              dataSourceMap.put(dbInfo, dataSourceProps);
					          }
					  
					          // 默认数据源
					          String defaultData = environment.getProperty(prefix + "default");
					          defaultDataSourceConfig = PropertyUtil.handle(environment, prefix + defaultData, Map.class);
					  
					      }
					  }
					  ```
						-
					- 这段代码实现了在Spring Boot应用程序中读取属性并绑定到指定类的功能。具体来说，它使用了Spring Boot提供的Binder类来将属性从给定的环境中绑定到指定的目标类。该方法接受三个参数：环境（Environment），属性前缀（prefix），以及目标类（targetClass）。它首先加载Binder类，然后使用get方法从环境中获取Binder对象，接着使用bind方法将属性绑定到指定类，并返回绑定结果对象。最后，从绑定结果对象中获取值并返回。如果在执行该过程中出现异常，它会将异常封装到RuntimeException中并抛出。
						- ```
						  public class PropertyUtil {
						  
						      private static int springBootVersion = 1;
						  
						      static {
						          try {
						              Class.forName("org.springframework.boot.bind.RelaxedPropertyResolver");
						          } catch (ClassNotFoundException e) {
						              springBootVersion = 2;
						          }
						      }
						  
						      /**
						       * Spring Boot 1.x is compatible with Spring Boot 2.x by Using Java Reflect.
						       * @param environment : the environment context
						       * @param prefix : the prefix part of property key
						       * @param targetClass : the target class type of result
						       * @param <T> : refer to @param targetClass
						       * @return T
						       */
						      @SuppressWarnings("unchecked")
						      public static <T> T handle(final Environment environment, final String prefix, final Class<T> targetClass) {
						          switch (springBootVersion) {
						              case 1:
						                  return (T) v1(environment, prefix);
						              default:
						                  return (T) v2(environment, prefix, targetClass);
						          }
						      }
						  
						      private static Object v1(final Environment environment, final String prefix) {
						          try {
						              Class<?> resolverClass = Class.forName("org.springframework.boot.bind.RelaxedPropertyResolver");
						              Constructor<?> resolverConstructor = resolverClass.getDeclaredConstructor(PropertyResolver.class);
						              Method getSubPropertiesMethod = resolverClass.getDeclaredMethod("getSubProperties", String.class);
						              Object resolverObject = resolverConstructor.newInstance(environment);
						              String prefixParam = prefix.endsWith(".") ? prefix : prefix + ".";
						              return getSubPropertiesMethod.invoke(resolverObject, prefixParam);
						          } catch (final ClassNotFoundException | NoSuchMethodException | SecurityException | InstantiationException
						                  | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
						              throw new RuntimeException(ex.getMessage(), ex);
						          }
						      }
						  
						      private static Object v2(final Environment environment, final String prefix, final Class<?> targetClass) {
						          try {
						              Class<?> binderClass = Class.forName("org.springframework.boot.context.properties.bind.Binder");
						              Method getMethod = binderClass.getDeclaredMethod("get", Environment.class);
						              Method bindMethod = binderClass.getDeclaredMethod("bind", String.class, Class.class);
						              Object binderObject = getMethod.invoke(null, environment);
						              String prefixParam = prefix.endsWith(".") ? prefix.substring(0, prefix.length() - 1) : prefix;
						              Object bindResultObject = bindMethod.invoke(binderObject, prefixParam, targetClass);
						              Method resultGetMethod = bindResultObject.getClass().getDeclaredMethod("get");
						              return resultGetMethod.invoke(bindResultObject);
						          } catch (final ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException
						                  | IllegalArgumentException | InvocationTargetException ex) {
						              throw new RuntimeException(ex.getMessage(), ex);
						          }
						      }
						  
						  }
						  ```
				- 其注入了一个DynamicDataSource的Bean对象：其实就是利用表示每个数据库元信息的哈希map来构造一个DriverManagerDataSource对象，对原有的datasourceMap进行了一下内容的重构。然后这里创建了一个DynamicDataSource对象，给这个对象初始化了两个信息：代表所有数据源信息的Map（键是数据源的名称、值是对应的DriverManagerDataSource对象）、默认的DriverManageerDataSource对象，这个对象被返回。因为这个类带有@configuration配置，所以这个对象是作为Bean被注入到了Spring容器中。
				  collapsed:: true
					- ```
					  @Bean
					      public DataSource dataSource() {
					          // 创建数据源
					          Map<Object, Object> targetDataSources = new HashMap<>();
					          for (String dbInfo : dataSourceMap.keySet()) {
					              Map<String, Object> objMap = dataSourceMap.get(dbInfo);
					              targetDataSources.put(dbInfo, new DriverManagerDataSource(objMap.get("url").toString(),
					                      objMap.get("username").toString(), objMap.get("password").toString()));
					          }
					  
					          // 设置数据源
					          DynamicDataSource dynamicDataSource = new DynamicDataSource();
					          // 下面的两个方法都是抽象路由数据源这个抽象类中定义的
					          dynamicDataSource.setTargetDataSources(targetDataSources);
					          dynamicDataSource.setDefaultTargetDataSource(new DriverManagerDataSource(defaultDataSourceConfig.get("url").toString(),
					                  defaultDataSourceConfig.get("username").toString(), defaultDataSourceConfig.get("password").toString()));
					  
					          return dynamicDataSource;
					      }
					  ```
					- ```
					  public class DriverManagerDataSource extends AbstractDriverBasedDataSource {
					      public DriverManagerDataSource() {
					      }
					  
					      public DriverManagerDataSource(String url) {
					          this.setUrl(url);
					      }
					  
					      public DriverManagerDataSource(String url, String username, String password) {
					          this.setUrl(url);
					          this.setUsername(username);
					          this.setPassword(password);
					      }
					  
					      public DriverManagerDataSource(String url, Properties conProps) {
					          this.setUrl(url);
					          this.setConnectionProperties(conProps);
					      }
					  
					      public void setDriverClassName(String driverClassName) {
					          Assert.hasText(driverClassName, "Property 'driverClassName' must not be empty");
					          String driverClassNameToUse = driverClassName.trim();
					  
					          try {
					              Class.forName(driverClassNameToUse, true, ClassUtils.getDefaultClassLoader());
					          } catch (ClassNotFoundException var4) {
					              throw new IllegalStateException("Could not load JDBC driver class [" + driverClassNameToUse + "]", var4);
					          }
					  
					          if (this.logger.isDebugEnabled()) {
					              this.logger.debug("Loaded JDBC driver: " + driverClassNameToUse);
					          }
					  
					      }
					  
					      protected Connection getConnectionFromDriver(Properties props) throws SQLException {
					          String url = this.getUrl();
					          Assert.state(url != null, "'url' not set");
					          if (this.logger.isDebugEnabled()) {
					              this.logger.debug("Creating new JDBC DriverManager Connection to [" + url + "]");
					          }
					  
					          return this.getConnectionFromDriverManager(url, props);
					      }
					  
					      protected Connection getConnectionFromDriverManager(String url, Properties props) throws SQLException {
					          return DriverManager.getConnection(url, props);
					      }
					  }
					  ```
				- 其注入了数据库路由策略接口的实现类DBRouterStrategyHashCode这个Bean对象
				  collapsed:: true
					- ```
					  @Bean
					  public IDBRouterStrategy dbRouterStrategy(DBRouterConfig dbRouterConfig) {
					      return new DBRouterStrategyHashCode(dbRouterConfig);
					  }
					  ```
					- ![image.png](../assets/image_1681461960687_0.png)
					-
					-
				- 其注入了事务模板这个Bean对象，这个Bean对象进行了两项初始化操作：一是设置数据源的事务管理器对象，二是设置事务的传播行为。事务模板是spring提供的一种编程式事务处理方式，在代码中控制事务的处理、提交、回滚等操作，可以将事务的处理过程和业务逻辑的实现分离开来；事务的传播行为是指当一个方法调用另外一个方法时，如何处理两个方法的事务边界，PROPAGATION_REQUIRED说的是如果存在事务就加入当前事务，否则创建一个新的事务。
				  collapsed:: true
					- ```
					   @Bean
					      public TransactionTemplate transactionTemplate(DataSource dataSource) {
					          DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
					          dataSourceTransactionManager.setDataSource(dataSource);
					  
					          TransactionTemplate transactionTemplate = new TransactionTemplate();
					          transactionTemplate.setTransactionManager(dataSourceTransactionManager);
					          transactionTemplate.setPropagationBehaviorName("PROPAGATION_REQUIRED");
					          return transactionTemplate;
					      }
					  ```
				- 其注入了DBRouterConfig这个Bean，获取路由的配置信息：
				  collapsed:: true
					- 数据库的个数、表的个数、路由key
			- DynamicDataSource继承AbstractRoutingDataSource抽象类：这个抽象类中定义了一个获取数据源的抽象方法determineCurrentLookUpKey，意思是决定当前的查询键是什么，而这个抽象方法是被这个抽象类中的determineTargetDataSource决定目标数据源的方法调用的，在这个方法中：首先会获取当前的查询键，然后解析这个查询键对应的数据源；若这个查询键本身为null那么得到的数据源也为null，此时将返回默认的数据源，若查询键不为null但是获取的数据源为null，那么抛出异常；如果数据源和查询键都不为null，那么将返回数据源对象。
			  collapsed:: true
				- ```
				  public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean {
				  	
				      ...
				      
				      protected DataSource determineTargetDataSource() {
				          Assert.notNull(this.resolvedDataSources, "DataSource router not initialized");
				          Object lookupKey = this.determineCurrentLookupKey();
				          DataSource dataSource = (DataSource)this.resolvedDataSources.get(lookupKey);
				          if (dataSource == null && (this.lenientFallback || lookupKey == null)) {
				              dataSource = this.resolvedDefaultDataSource;
				          }
				  
				          if (dataSource == null) {
				              throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]");
				          } else {
				              return dataSource;
				          }
				      }
				      
				      @Nullable
				      protected abstract Object determineCurrentLookupKey();
				  }
				  
				  ```
				- ![image.png](../assets/image_1681462528386_0.png)
					- 当size本身不为2的整除次幂时，
					  collapsed:: true
						- size - 1为偶数时，key & （size - 1）必然也为偶数，导致有一般的索引空间都未被使用而浪费了
						- size - 1 为奇数时，（size - 1）的二进制表示中地位也可能包含若干个0，key & (size - 1)的结果中对应的若干位也必然是0，这就导致有一部分空间被浪费了
						- 无论是奇数还是偶数，那么都会存在空间浪费
						- 如果size本身为2的整数次幂，那么（size-1）中除了高位从1变成0，所有后续位置都从0变成1，这样（size - 1）& key的结果完全取决于key对应位置本身，同时也保证了按位与的取值范围是[0，size - 1]
			- DynamicMybatisPlugin继承了Interceptor接口，实现了这个接口中的intercept方法，该类的类名上方添加上了@Intercepts注解，这个注解的参数代表要拦截的签名：要拦截的类、要拦截的方法名称以及方法的参数
			  collapsed:: true
				- ```
				  @Intercepts({@Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})})
				  public class DynamicMybatisPlugin implements Interceptor {
				  }
				  ```
	- 分库分表中间件的整个工作流程是什么？
	  collapsed:: true
		- ![image.png](../assets/image_1681480385871_0.png)
		- https://gitee.com/XhyQAQ/xhy-db-router-springboot-starter#%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84
	- 为啥分库分表中不使用默认的斐波那契散列？
	  collapsed:: true
		-
	- 在一个事务里面切换数据源，为什么会导致数据源失效的？你的项目中是怎么解决的？
	  collapsed:: true
		- ![image.png](../assets/image_1681473000906_0.png)
		- 如果一个事务执行多种不同的数据操作，比如有些操作需要进行分库分表、另外一些不需要进行分库分表，那么在一个事务内就需要切换数据源，但是每切换一次数据源，就会导致数据库连接断开一次，需要重新建立一次数据库的连接，而一次事务只能在一个数据库连接中有效；
		- 解决办法就是：在进入这个事务之前，把路由计算出来然后配置下数据源，然后把dao层中的@DBRouter注解给去掉，这样在进入一个事务之后再切换数据源就不会出问题了。因为dao层中的@DBRouter注解是导致切换数据源的原因
		- 切换动态数据源还有其他的方法：
			- https://blog.csdn.net/qq_35599414/article/details/109384550
	- SPI是什么？中间件中SPI起到了什么样的作用?
	  collapsed:: true
		- SPI是服务提供接口。在SPI机制中，服务提供者提供了实现了接口的实现类，并在resources/META-INF/services下创建一个名称为全限定接口名的文件，在这个文件写上实现类的全限定类名。当服务使用者通过标准API来使用接口服务时，会从SPI配置文件中读取信息，然后加载和初始化接口的实现类。
		- ![image.png](../assets/image_1681484424571_0.png)
			- 将中间件整合进SpringBoot，也通常使用SPI来进行自动装配。做法是：在resources/META-INF/spring.factories文件中写入org.springframework.boot.autoconfigure.EnableAutoConfiguration=DataSourceAutoConfig即可。
			- ![image.png](../assets/image_1681485134115_0.png)
				- SpringBootApplication 注解 -> EnableAutoConfiguration 注解 -> import进了一个AutoConfigurationImportSelector类 -> loadSpringFactories方法中会用类加载器去加载META-INF/spring.factories文件
	- 为什么需要使用分布式的ID？
	  collapsed:: true
		- 因为数据库被拆分后，比如说分表，不能再依赖于数据库自身的自增主键了，不然不同数据库中的用一张表的ID不能保持连续，甚至有可能重复，所以可以使用雪花算法来生成分布式的ID
	- 什么是编程式事务？什么是声明式事务？与声明式事务有什么区别？在你的项目中为啥使用编程式事务？
	  collapsed:: true
		- 声明式事务说的是通过XML文件或者注解来声明事务的行为，而不需要在代码中显示去写事务执行的逻辑；好处就是将业务逻辑和事务管理分开，使得代码更容易阅读，也更容易维护；spring中使用AOP来实现声明式事务，拦截目标方法，在方法的执行前后开启和提交事务。
		- 编程式事务说的是用代码中显示地开启和关闭一个事务，而不是使用声明式事务来自动管理事务。
		- 编程式事务能够适应特殊场景下的事务控制，这也意味着会增加代码的复杂性和维护难度。
	- 扰动函数的作用？
	  collapsed:: true
		- HashCode是32位，而HashMap的容量是16，将hashcode的高位向右移位16位，再与低位进行异或运算，这样是为了尽可能减少碰撞。
	- 除了分库分表中间件，是否了解其他的各种中间件？
	- Kafka你是怎么使用的？对于Kafka你有哪些了解？
	- utf8mb4是什么数据类型，和utf8有什么区别？
	  id:: 64351412-bb64-45b2-8695-5faf7d34e420
	  collapsed:: true
		- iridescentlevin@foxmail.com
	- 描述一下你整个项目的业务流程？
	- Redis分布式锁你是怎么设计的，为啥要这么设计，可不可以再进行优化？
	- 什么是Restful接口？
	- 了解RabbitMQ吗？RabbitMQ和Kafka有什么区别？
	- Mybatis中的mapper文件你是怎么理解的？有什么作用?
	- spring中的容器在源码级别是怎么实现的？
	- 你对其他的中间件有什么了解吗？
	- Spring中的@ConditionalOnMissingBean注解是什么含义？有什么作用？
	  collapsed:: true
		- 是spring中的一种条件注解，只有spring容器中不存在对应的Bean时才会创建一个新的Bean。这个注解可以进行有条件限制的创建和注入Bean。
	- 项目里用到了MySQL，它的底层结构是什么？
	  collapsed:: true
		- 数据库存储引擎和数据库服务器组成, 存储引擎负责数据的存储和检索，数据库服务器处理用户请求、管理数据库存储引擎、执行sql语句、维护系统安全。
	- 重复读和幻读的区别是什么？
	- B+树的查询只访问一次磁盘吗？
	- Java项目里怎么用的Redis？为什么要用Redis？
	- Java 项目里怎么用的 MQ ？ 为什么要用消息队列？
	- 平常刷算法题，刷了哪一类算法题？
	- Zookeeper是什么？Zookeeper提供了什么？你了解Zookeeper中选举的概念吗? 你的项目中哪些地方用到了Zookeeper?
		- Zookeeper是一种服务注册中心，更准确地来说是一种分布式的任务调度程序，可以维持分布式应用程序的一致性，分布式应用程序可以通过Z
	- 注册中心是什么？注册中心有什么作用？
	  collapsed:: true
		- 注册中心是服务发现模式的一种实现，为服务提供者和服务消费者之间的通信提供协调和管理。服务提供者在启动时向注册中心注册自己的服务，并定时向注册中心发送心跳来表明当前服务的可用性；服务消费者会从注册中心中查找自己所需的服务，根据负载均衡的要求选择其中一台机器来提供服务。注册中心可以动态地增加或者减少服务提供者，而服务消费者无需知道服务提供者的具体地址，只需要在注册中心中查询即可。
		- 注册中心提供了一种简单的方式来实现服务发现、负载均衡和故障转移等，并且还提供了日志、统计和服务监控等功能，增加了分布式系统的可用性和稳定性。
- [[反问内容]]
-
-