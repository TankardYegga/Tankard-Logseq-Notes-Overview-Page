- [[高频面试问题]]
-
- [[java基础]]
	- HashMap和HashTable的区别？
		- 线程安全：
			- HashTable的所有方法都使用synchronized来修饰，是线程安全的，而HashMap是线程不安全的，因此HashMap的效率也更高
		- 用法：
			- HashMap的key和value都可以为null，而HashTable不可以
			- HashTable的contains(Object value)和containsValue(Object value)的功能一样，都是判断是否存在某个特定的value
			- HashMap使用Iterator来进行遍历，而HashTable使用Enumeration来遍历
		- 原理：
			- HashTable的hash数组默认大小是11，扩容时是old * 2 + 1；HashMap的hash数组默认大小是16，而且一定是2的指数
			- 哈希值的计算方式不同：HashTable直接使用对应的hashCode()方法来计算；而HashMap则重新计算hash值，且用与运算来代替求模运算
			- HashTable是基于陈旧的Dictionary类的，而HashMap是JAVA 1.2 引进的Map接口的一个实现
			-
	- HashMap和ConcurrentHashMap的区别？
		- ConcurrentHashMap其在JDK 1.5之后出现。两者并不出现在同一个包中，两者的父类在一个包中，但是子类不在一个包中。
		  collapsed:: true
			- HashMap和ConcurrentHashMap的父类都是AbstractMap。这个类位于java.util包下。
			- HashMap类位于java.util包下。而ConcurrentHashMap类位于java.util.concurrent包下。
			- 所以，它们各自的父类是AbstractMap，并且HashMap位于java.util包，ConcurrentHashMap位于java.util.concurrent包
		- HashMap是非线程安全的，但是ConcurrentHashMap（并发包下的）是线程安全的，其降低了加锁的粒度。ConcurrentHashMap在HashMap的基础上，将数据划分为多个segment, 默认是16个(Concurrency Level),  每次操作对一个segment加锁，降低了多线程锁得几率，提高并发效率
		-
	- JAVA中如何实现代理机制？
		- JDK动态代理：
			- 代理类和目标类实现相同的接口，用到InvocationHandler接口
		- CGLIB 代理：
			- 代理类是目标类的子类，用到MethodInterceptor接口
			-
	- ArrayList和LinkedList的区别？
		- 前者由数组实现，后者由双向链表实现，因而ArrayList进行增加、删除操作比LinkedList慢，但是ArrayList进行查找和修改值时需要进行递归
		- LinkedList同时还实现了Queue接口，因而还具有offer、poll、peek等操作
		- ArrayList是非线程安全的，另外一个也是基于数组的List接口实现类Vector，其是线程安全的。但是一般来说，在多线程方面更多使用CopyOnWriteArrayList，其适合诸如缓存等读操作远远多于写操作的场景，发生修改时做拷贝，新老版本进行分离，保持了读的高性能
		-
	- 为什么LinkedList使用双端队列？
		-
		-
	- JVM对象的内存空间包含哪几个部分？其中的对象头包含哪些信息？
		- 包含markword(与电脑的位数相同，64位电脑就是8B，32位电脑就是4B)、class pointer（指向obj.class），instance data(类的成员变量数据，但是字符串引用类型的成员变量的大小只有4字节，与字符串的长度没有关联）,  padding(确保字节的总数目是4的倍数，比如当前只有17个字节，那么需要补充3个字节使其变成20个字节）
		- 对象头由markword和class pointer组成，即object header
		- 对象头包含三类信息：
			- 锁信息：
				- 当synchronized(obj){ClassLayout.parseInstance(obj).toPrintable()}时，默认在对象头的markword中加入锁信息，一般是轻量级的自旋锁。
			- hashcode信息
				- 当调用obj.hashCode()后，其哈希信息被记录在了该对象obj的markword中，所以下次再调用hashCode时，不用重新计算，而是直接在markword中取出来
			- GC
				- 现在JVM的垃圾回收算法用的是三色标记，所以markword记录了对应的“颜色”
				-
	- JVM中的对象该如何定位？
	- 字符串对象一定在栈上吗？
		- 不一定，因为该字符串对象可能是某个对象的成员变量
	- JDK1.8使用的垃圾回收算法是什么？
		- 使用的是 PS + PO 算法
	- java中的对象都是放在堆上吗？
		- main函数中声明的局部变量都放置在栈上
		- 栈中方法区的局部变量，当当前方法结束时，系统会自动回收栈中该方法的空间，也就是将栈中的指针指向调用当前方法的上一个方法，这块区域的回收并没有用到垃圾回收器
		- 但是栈的默认空间比较小，只有256K，且并不是所有对象都适合放在栈中
		- 判断对象是否放在栈上有两个标准：
			- 一是逃逸分析：如果该对象被其他对象所引用，那么不能放在栈中，也就是要分析对象的作用范围是否为逃逸出方法的范围，
			- 二是标量替换：只有最基础的数据类型才能替换
			-
	- java中对象的创建过程？
		- 分为三步：第一步是new操作，为对象在内存当中分配空间，按照markword、class pointer、instance data和padding的存储结构来分配，对象的成员变量使用默认的初始值；第二步是调用构造器，完成对象的初始化，包括成员变量值的显示赋值；第三步是建立关联，将引用变量 赋值为 对象的内存地址。
	- 为啥要使用double check lock?
		- 实际上只加了一个synchronized关键字在函数的内部，这里的lock指的是对象不为空的这个判断操作。里面的第一个lock（内部的lock），是为了保证instance的同步，如果当前线程已经在创建对象了，给当前线程加锁，那么其他线程无法执行当前代码块，也就是根本都不会去判断instance实例是否不为空，更不用说会去创建对象了，等到当前线程解锁，其他线程都会判断 instance != null 为false，所以也都不会继续创建对象了；里面的第二个lock (外部的lock)，如果不加上，导致的问题是每个其他进程都在加锁这一步等待，而加锁操作非常耗时，如果加上外部的判断，可以同样起到不创建对象操作的目的，但是会大幅提高速度，进而提高并发性能。
		- ```
		  if(instance ! = null){
		  	synchronized (A.class){
		         if(instance ! = null){
		         		try{
		              	A a = new A（）;
		              } catch(Exception e){
		              	
		              }
		         }
		      }
		  }
		  
		  ```
	- Class实例究竟在Method area还是在Heap中？
		- ![image.png](../assets/image_1678967682039_0.png)
		-
	- 什么是字节码以及它的组成？
	- 双亲委派机制是什么？它有什么作用？
		- 双亲委派机制说的是：
			- 除了顶层的启动类加载器以外，其他所有的类加载器在加载之前，都会委派给它的父加载器进行加载。这样一层一层向上传递，直到祖先们都无法胜任，它们才会真正的加载。
			- 作用：
				- 通过带有优先级的层级结构可以避免类被重复加载；
				- 确保JAVA程序平稳安全运行，保证JAVA核心API定义的类型不会被随意更改
	- JAVA 获取反射有哪三种方法?
		- 先new一个对象，然后通过对象.getClass方法获取Class对象
		- Class.forName(路径）来进行反射
		- 通过类名.class来进行反射
	- HashMap的底层数据结构是什么？
		- JDK 7 中是 HashMap的底层是 数组 和 链表 组合起来的 链表散列结构：就是把 key的hashCode通过扰动函数得到一个哈希值，然后把这个哈希值和size - 1进行按位与，得到了在数组中的对应位置；如果数组中的这个位置已经有元素，那么判断这个元素与当前元素的key和hash值是否相同，若相同则进行覆盖，若不同则通过拉链法解决冲突
		- JDK 8 中 当同一个链表上的元素个数大于8时，再判断此时hashmap的数组长度是否已经大于等于64，如果是，则将链表转化成红黑树，否则只是进行resize来扩容
	- HashMap的扩容机制是怎么样的？
		- JDK：
			- 如果是无参构造函数的hashmap对象，则初始时的数组为null，当第一次put时，就会进行第一次扩容，长度默认为16
			- 如果是有参构造函数的hashmap对象，这个参数是用来指定容量的，先会找到大于给定参数的一个2的整数次幂来作为数组的阈值；然后第一次put时，会将阈值赋值给容量，并将阈值设置为 容量 乘以 负载因子。
	- Java怎么实现单例继承？
	- ==和 equals（）的区别？
	- String的引用不可变的问题？
	-
	- https://mp.weixin.qq.com/s/s6ZhOvyLmPvdQ8snvt9H_Q
-
- [[数据库]][[MySql]]
	- 什么是数据库的事务？
		- 事务是一组逻辑操作，要么都执行，要么都不执行。它是数据库并发调度的基本单位，其执行的结果必须使数据库从一种一致性状态转换到另一种一致性状态。
		- 举例来说就在A给B转账，给A的账号减小m元和给B的账号增加m元，这两个操作必须都执行或者都不执行，如果A执行了但是B不执行，这样就不对了。
	- 事务的ACID特性指的是什么？
		- Atomicity 原子性：
			- 事务的执行具有原子性，要么都执行，要么都不执行，不能分开；事务是最小的执行单元
		- Consistency 一致性：
			- 在事务执行前后，数据库中的数据始终保持一致，不同事务对于同一数据的读取结果应该是相同的
		- Isolation 隔离性：
			- 并发访问数据库时，一个用户的事务并不受到其他事务的干扰，各个并发事务之间数据库是独立的
		- Durability 持久性：
			- 事务对数据库的改变是持久的，即使数据库崩溃了也不会这一点所有改变
	- 事务的隔离级别有哪些？MySql和Oracle的隔离级别是什么？
		- 事务的隔离级别有四种：
			- Read-Uncommited (读取未提交)：
				- 是最低的隔离级别，允许读取尚未提交的数据更新，脏读、幻读和不可重复读仍然有可能发生
			- Read-Commited (读取已提交)
				- 允许读取并发事务已经提交的数据更新，可以阻止脏读，但是幻读和不可重复读仍然有可能发生
			- Repeatable-Read (可重复读)
				- 对同一字段的多次读取结果是完全一致的，可以阻止脏读和不可重复读，但是幻读仍然有可能发生
			- Serializable (可串行化)：
				- 完全满足ACID原则的最高隔离级别，各个事务之间串行执行，也就不存在相互干扰，也就是说可以完全阻止脏读、幻读和不可重复读
		- MySql的隔离级别是 REPEATABLE_READ,  Oracle的隔离级别要比Mysql低一级，也就是READ_COMMITED
	- 如何理解事务隔离机制？
		- 事务隔离机制是基于锁和并发调度实现的。其中并发调度使用的是MVCC(Multiversion Concurrency Control), 即多版本的并发控制，通过保存修改过的旧版本信息来实现并发一致性的读和回滚特性
	- 什么是脏读、幻读和不可重复读？
		- Dirty Read:
			- 一个事务已经提交了数据更新，此时另外一个事务读取这个数据，但是前面的事务进行了rollback操作，那么后面这个数据读取到的数据就是不正确的了
		- Phantom Read:
			- 一次事务两次查询之间读取到的数据记录数目不一样，应该是两次查询间有其他事务插入了新的数据记录
		- UnRepeatable Read:
			- 一次事务两次查询的结果是不同的，应该是两次查询之间有其他事务对部分数据进行了更新
	- 对MySql的锁了解吗？
		- 锁是一种保证访问次序的机制，为了减小或者避免数据库中并发事务导致的数据不一致的问题。
		- 当一个事务加上锁之后，其他事务必须等待锁释放才能访问和修改对应的数据。这就像酒店房间的锁，多个人同时申请一个房间，但是只有一个人会获得这把锁，然后使用该房间，只有当这个人归还钥匙房间时，剩下人中的一个才能使用。
	- 按照锁的粒度有哪些锁？
		- 可以分为行级锁、页级锁、以及表级锁
		- 行级锁只对当前操作的行进行加锁，表级锁只对当前操作的整张数据表进行加锁，而页级锁则采取了折衷的方案，对当前操作的页进行加锁，一次锁定一组数据记录
		- 三类锁的加锁开销和加锁时间依次递增；因为粒度越细，造成的冲突次数也就越少，所以三者的并发度是在依次递减的；三者中行级锁和页级锁都有可能发生死锁，但是表级锁不会发生死锁；行级锁可以分为共享锁和排他锁，表级锁也可以分为表共享读锁(共享锁）和表独占写锁（排他锁）
	- MySql支持的锁的粒度是什么？
		- 取决于具体的存储引擎：如果是MYISAM引擎，则支持表级锁；如果是INNODB引擎，则支持行级锁和表级锁，默认使用行级锁
	- 按照锁的类别有哪些锁？
		- 类别上分为共享锁和排他锁：共享锁就是读锁，一个用户的事务在读取数据时可以加上共享锁，可以同时加上多个共享锁；排他锁就行写锁，一个用户的事务在修改数据时只能加上一个排他锁，与其他的排他锁、共享锁都是互斥的
		- 多个用户可以同时看房；但是当一个用户入住时，其他用户无论是入住还是看房都不能进行了
	- INNODB中的行级锁是怎么实现的？
		- 是使用索引实现的，比如：“select * from table_with_index where id = 10 for update” 语句对id=10的数据记录的更新操作加上了行锁，for update的含义是进行行锁锁定的条件。这里因为id对应的就是索引列，所以才能进行行锁，如果是非索引列，则无法进行行锁定，此时INNODB将进行表锁定，并发也就无从谈起。
	- 数据库的乐观锁、悲观锁分别是什么？两者各自适用于什么样的场景?
		- 乐观锁和悲观锁是并发控制中的两种技术手段，乐观锁是乐观的并发控制，悲观锁是悲观的并发控制
		- 悲观锁是假定并发冲突会发生，屏蔽一切可能破坏数据完整性的操作；在查询完数据后就给事务加上锁，直到提交事务为止；通常使用锁机制来进行实现。而乐观锁是假定不会发生并发冲突；在提交事务时才检查是否违法数据完整性；在修改数据时使用version的方法来对事务进行加锁；通常使用版本号机制和CAS算法来实现。
		- 乐观锁适用于多读写少的场景，也就是写操作真的较少时，因为这样冲突次数就会更少，使用乐观锁能够降低锁的开销，从而增大了系统的吞吐量；悲观锁适用于多写的场景中，因为此时冲突发生会很频繁，会导致上层应用不断地进行retry，反而降低了性能
	- 什么是死锁，怎么解决？
		- 死锁指的是：两个或者多个事务各自占用同一资源不释放，但又相互请求对方的资源，造成请求循环的现象。
		- 可以采取的方法有：
			- 当不同程序并发请求存取多张表时，尽量约定好访问的次序，可以降低死锁的发生次数；
			- 在同一事务内，尽量一次性占有所需的所有资源，可以极大降低死锁发生的概率；
			- 对于经常发生死锁的业务，可以升级锁的粒度，比如将行级锁变为表级锁；如果业务处理不方便，可以使用乐观锁或者分布式事务锁
	- 大部分数据库采用什么隔离级别?
		- 大部分都采用READ_COMMITED的隔离级别，能阻止脏读，但是不可重复读和幻读仍然有可能发生
		- InnoDB存储引擎默认使用READ_COMMITED并不会有任何性能损失，其只有在分布式事务的情况下才会使用Serializable的隔离级别
		-
	- 数据库的三大范式是什么？
		- 第一范式：数据库的所有列都不可再拆分
		- 第二范式：在第一范式的基础上，非主键列完全依赖于主键，不能是只依赖于主键的一部分
		- 第三范式：在第二范式的基础上，非主键列只能依赖于主键列，不能依赖于其他非主键列
		- 在进行数据库的设计时，要尽量遵守三大范式，但是经常为了性能的原因而妥协数据库的设计。
	- VARCHAR和CHAR类型的比较？
		- varchar可以用于存储变长的字符串，比char类型更节省空间；varchar通常使用1到2个字节来记录长度，当长度不超过255个字节时，使用一个字节来存储长度，否则用两个字节
		- char用于存储定长的字符串
			- 一是当需要频繁进行变更时，char比varchar更适合，因为会有更少的内存碎片；
			- 二是对于非常短的列，使用char更合适，因为更长的列会在排序时会消耗更多的内存空间
		- 对于TEXT/BLOB类型，尽量不要使用，因为其在查询时会需要用到临时表，会有严重的内存开销
	- 索引是什么？
		- 索引是数据库管理系统中用于排序的一种数据结构，可以方便地对数据库进行快速的查询和更新操作，索引通常通过B树和B+树来进行实现
		- 索引是一种特殊的文件（InnoDB数据表的索引是表空间的一部分），包含了数据库中所有记录的指针引用
		- 更通俗地来说，索引就相当于目录，对文件内容建立索引方便查找具体的记录，索引本身是一个文件，因而会占据一定的物理空间
	- 索引有哪些优缺点？
		- 两个优点：
			- 大大加快了数据查询的速度，这也是使用索引最为主要的原因
			- 在使用索引进行查询时，可以使用优化隐藏器，提高了系统性能
		- 两个缺点：
			- 创建索引和维护索引需要花费时间，当对数据记录进行增删改时，对应的索引也需要进行增删改
			- 索引需要使用一定的空间
	- 怎么样能够提高索引的效率呢？
		- 对join语句匹配关系的on涉及的字段建立索引，能够提高效率
	- 什么是覆盖索引？
		- 如果待查询的字段都已经建立了索引，那么执行引擎就会直接在索引表里进行查询而不是直接访问原始数据，这就叫做覆盖索引，否则只要有一个查询字段没有索引，都需要进行全表扫描
		- 所以仔细选择select后的查询字段，使其在覆盖索引的字段范围内，能够提高查询效率
		- 因为索引能提高效率主要就是因为体积小，所以不建议为了覆盖索引而给过多的字段设置索引
	- 怎么避免不可重复读？
		-
	- B树和B+树的区别？两者各自的优点是什么？数据库为啥使用B+树而不是B树？
		- B树的内部节点和叶子节点都包括键和值，但是B+树内部节点只包括键，叶子节点同时包括键和值；B树的叶子节点之间没有关联或者说各自独立，B+树的叶子节点通过类似于链表的方式进行单向串联
		- B树中每个节点都包括键和值，所以把查询频率高的热点数据放在根节点附近，就可以大大提高查询效率，这适用于特定数据进行多次重复查询访问的场景
		- B+树中有两个优点: B+树的内部节点只有键，没有值，所以在内存页中可以存储更多的键值，有利于更快地缩小查询范围； B+树的叶子节点通过一条链进行相连，当需要进行全表查询时，先花费O(logN)的时间找到最小的节点，再沿着链花费O(N)时间进行查找，而B树则需要在每一层进行遍历，这需要更多的内存页置换次数，也就会花费更多的时间
		- 可以从三个方面来说明数据库使用B+树的原因：
			- 查询功能：
				- B树只支持随机索引，而B+树同时支持随机索引和顺序索引
			- 空间效率：
				- B+树的空间利用率更高，减少了磁盘IO的读写次数。因为B+树的内部节点只存储了键而没有存储关键字对应的指针，比B树的内部节点小，所以盘块中存储的节点关键字数量也更多，一次性从内存中读取的关键字数量也越多。
			- 查询效率：
				- B+树的查询效率更加稳定：
					- B树的性能等价于对关键字集合进行一次二分查找，越靠近根节点的关键字查询效率越高；而B+树中的叶子节点存放键和值，所以任何关键字段查询都需要从根节点到叶子节点，每个关键字的查询效率是相近的
					- B+树中可以沿着叶子节点间的链进行全表查询，方便基于数据库的范围查询操作和节点的增删操作
					-
		-
	- 关系型数据库和非关系型数据库的区别？
		- 关系型数据库是指用二维表格这种关系模型来存储数据的数据库
		- 非关系型数据库以键值对存储，且结构不固定
	- 详细描述一下MVVC？MVCC具体是如何实现事务的隔离性的？
		- MVCC是多版本的并发控制：
			- 其核心思想是：通过保存数据的历史版本，通过数据行的多个版本管理来实现数据库的并发控制。根据事务的开始时间，不同事务对于同一张表、同一时刻看到的数据可能是不一样的。
			- 其解决了三类问题：
				- 解决了读写之间阻塞的问题：MVCC可以使得读写之间相互不阻塞，读不阻塞写，写不阻塞读，大大提高了并发处理能力
				- 降低了死锁的概率：读的时候不需要加锁，写的时候也只需要对必要的行进行加锁
				- 解决了一致性读的问题：一致性读又叫做快照读，指的是在读取某个时间点的快照时，只能读取到这个时间点之前的数据，不能读取这个时间点之后的数据
			- MVCC的实现：
				- MVCC没有一个统一的实现标准
			- MVCC与隔离级别的关系：
				- MVCC只在可重复读和读提交这两种隔离级别下工作
				- 其他两种隔离级别与MVCC不兼容：
					- 读未提交只读取当前最新的数据行，而不是符合当前事务版本的数据行
					- 串行化会对所有的行都加锁
		- InnoDB中的MVCC的工作方式：
			- INNODB中的MVCC使用的是乐观锁的方式
			- 对于INNODB来说，其聚簇索引中记录中存在三个隐藏的列，分别是ROW ID、事务ID和回滚指针。ROW ID是一个隐藏的自增ID,  如果没有设置主键，则innodb为会ROW ID建立聚集索引树；事务ID，记录的是最后一次修改该记录的事务ID; 回滚指针，是指向undo log中上一个时间点的数据记录，或者说上一个版本的数据记录。当事务更改某一条数据记录时，首先会对该行加上排他锁，然后会写入redo log，接着会将修改前的记录拷贝到undo log中去，最后修改记录，将当前事务的ID写入，并让回滚指针指向undo log中的最后一条记录；当事务正常提交时，innodb只需将事务的状态修改为commit状态即可，并不需要额外的工作； 当事务进行rollback， 需要利用回滚指针找出事务修改之前对应的版本，然后恢复。
	- MVCC可能出现幻读情况吗？
		- 可能，当MVCC利用undo log、版本链、以及Read View可以在快照读模式时，没有幻读，但是使用当前读模式时，不能避免幻读问题，因为当前读始终读取最新数据
	- undo log和redo log具体是怎么工作的？有什么区别？
		- redo log把执行的sql语句写到log文件中去，当数据库进行recovery时重新执行log文件中记录的sql操作即可。当客户端执行sql更新语句时，redo log会被写到redo log buffer中；当客户端执行commit命令时，log buffer中的内容会视情况被刷新到磁盘中去。redo log本身是存储在磁盘中的数据文件。
		- undo log是为了回滚，是把当前事务执行前的数据行拷贝到undo log buffer中，然后在适合的时候也会被刷新到磁盘中去。undo log 和 redo logo的缓冲区一样都是环形的，当环形区域填满时，就需要将部分内容刷新到磁盘中去；但是磁盘上并不存在一个单独的undo log文件，所有的undo log文件都存储在主ibd数据文件中（表空间），即使客户端设置了每个表都对应一个数据文件
	- 怎么在mysql中实现乐观锁？什么是版本号机制，什么是CAS算法？
	- 为什么innodb使用了自增主键？
	- Mysql如何实现主从同步？mysql为啥需要主从同步？
		-
	- innodb和myisam锁不同？
		- mysql中的锁几乎对用户是透明的；
		- myisam只支持表级锁定，而innodb同时支持表级锁定和行级锁定，锁定粒度小而并发程度高
	- innodb和myisam的索引有什么不同？
		- 两者的实现都是B+树索引，但是myisam是堆表，而innodb是索引组织表
		- innodb是聚簇索引，而myisam是非聚簇索引
		- innodb主键索引的叶子节点直接存储了行数据，而myisam索引的叶子节点存储的是行数据的指针，需要再一次寻址才能找到行数据
		- innodb非主键索引的叶子节点存放了主键和其他带有索引的列数据，因此查询时做到覆盖索引会很有效
	- 存储引擎该怎么进行选择？
		- 通常情况下若没有特殊的需求，使用默认的innodb存储引擎即可
		- myisam适合读写插入为主的应用程序，比如新闻门户网站、博客系统；innodb适合更新（删除）频繁、需要保持数据的完整性、高并发、需要支持事务和外键的场景，比如OA自动化办公系统。
	- INNODB引擎有哪些特性？
		- 有四大特性：
			- 预读(ReadAhead)
			- 二次写入(DoubleWrite)
			- 插入缓冲（InsertBuffer）
			- 自适应哈希索引
	- 索引有哪几种类型？
		- 有三种类型：
			- 主键索引：
				- 数据列不允许为null，也不允许重复
				- 一个表只能有一个主键，所以也就只有一个主键索引
			- 唯一索引：
				- 数据列不允许重复，但可以为null
				- 单个的唯一索引：
					- alter table x add unique(column)
				- 组合索引：
					- alter table x add unique(x, y)
			- 普通索引：
				- 基本的索引类型，既没有唯一性的限制，也可以为null
					- alter table x add index (y)
					- alter table x add index (y, z)
					- 全文索引是普通索引中特殊的一种，是目前搜索引擎使用的关键技术之一
						- alter table x add fulltext (y)
	- 需要复习一下mysql的sql查询语句
	- mysql中除了innodb还有什么存储引擎？
	- 索引的设计原则有哪些？
	- mysql的复制原理是什么？
	- mysql聚簇索引和非聚簇索引的区别是什么？
	-
-
- [[Redis]]
	- Redis和mysql的区别？
		- mysql是将数据持久化存储到磁盘中，功能强大，但是资源消耗大、从磁盘中读取速度慢；redis是将频繁访问的数据存储到缓存当中，缓存的读取速度快，大大加快了运行速度，但是缓存数据保存的时间是有限的。
	- Redis为什么这么快？
		- 有五个原因可以解释：
			- 基于内存，非常快速
			- redis自己专门设计了数据结构，数据结构简单
			- 使用单线程，避免了不必要的上下文切换和竞争条件，避免了多进程或者多线程下切换导致的CPU消耗、不用考虑各种锁的问题，不必有加锁和释放锁等各种操作，不会产生死锁而造成性能损耗
			- 使用多路复用IO模型，非阻塞IO
			- 使用了不同的底层模型，其底层实现方式和客户端之间通信的应用协议不同，其使用的是自己设计的VM，而一般的系统调用系统函数时，会浪费一定的时间去请求和移动
	- Redis有哪些数据结构？
		- 有5种基本数据结构：String、Hash、Set、List、Sorted Set
			- 有三种特殊的数据结构：Bitmap、HyperLogLog、Geospatial。其中 Bitmap和HyperLogLog都是String类型，GeoSpatial是Sorted Set类型
	- Redis的缓存淘汰策略是什么？
		- 从高并发来说：
			- 直接操作缓存能够承受的请求数是远远大于操作数据库的，因此可以把数据库中的一部分数据转移到缓存中去，用户的请求将直接存储到缓存中去而不需要经过数据库
		- 从高性能上来说：
			- 用户第一次获取数据库中的某些数据时，从磁盘读取会比较缓慢，将这部分数据存入缓存中，那么用户后续获取时可以直接从缓存中获取，大大加快了读取速度。当数据库中的对应数据发生了变化后，也将变化同步更新到缓存中去。
	- 缓存雪崩是什么？怎么解决？
		- 在某一时刻有大量的缓存失效 ==> 大量请求被直接打到数据库上，数据库的压力巨大，高并发时会导致数据库宕机 ==> 运维若重启数据库，又会有新的请求流量把数据库打死
		- 解决方案：
			- 预防缓存雪崩的发生：
				- 每个缓存在原有的失效时间上随机延长1-5min，这样所有的缓存不会在同一时刻大量失效
			- 缓存雪崩发生之时的兜底策略：
				- 使用熔断机制：当流量超过一定阈值，系统会返回“系统拥挤”之类的提示，防止过多的请求打在数据库上，能够保证一部分用户能够正常使用，另一部分用户多刷新几次后也可以得到结果
				- 提高数据库的容灾能力：采取分库分表、读写分离等策略
				- 提高redis的容灾能力：为了防止redis宕机，可以使用redis集群
	- 缓存穿透是什么？怎么解决？
		- 正常情况下，我们通过key来从缓存中查询数据 ==> 若某个请求中的key在数据库中不存在，就会去数据库中查询 => 若存在大量的这样的请求，这些请求就像“穿透”缓存一样直接达到数据库上
		- 解决方案：
			- 把不存在的key存入redis：
				- 若缓存和数据库中都不存在该key，就把该key存入缓存中，对应的value=“null”，当该key再次查询时，就会返回不存在
				- 但是如果每次的key都不一样，那么该策略就失效
			- 使用布隆过滤器：
				- 布隆过滤器的作用是：如果它说某个key不存在，那么就一定不存在，如果它说某个key存在，那么这个key有很大的概率存在。在缓存前面加上一层布隆过滤器，在查询之前先去布隆过滤器中判断该key是否存在，如果不存在则直接返回不存在。
	- redis中的调表，了解吗？
	- 为什么redis不用B+树，为什么mysql不使用调表？
	- redis数据同步（全量，增量）？
	- redis cluster集群和哨兵？
	- redis持久化方案
	- Redis的Zset和set有什么区别？
	- 缓存失效是什么？缓存一致性是什么？redis热点数据更新？
	-
-
- [[并发]]
	- 说一下什么是线程池？线程池如何创建？创建线程池时主要设置什么属性？
		- 线程池是一种多线程的处理形式，处理过程中把任务提交到线程池，任务的执行交给线程池来完成。一个线程池管理一组工作线程，同时还维护有一个队列用来管理等待执行的任务。
		- 线程池的创建方式：
			- java中创建线程池有两类方法：一类是通过并发包下的Executors工厂类，这是类是对Executor接口的实现，可以提供四种不同的线程池；另一类是通过ThreadPoolExecutor类进行自定义创建。
		- 创建线程池时大概有7个重要的参数：
			- corePoolSize:
				- 线程池的核心线程数目。在核心线程没有设置allowCoreThreadTimeOut为true的，核心线程将一直保持存活，不会过时被回收。
			- maximumPoolSize:
				- 线程池可以容纳的最大线程数目。当活动线程的数目（核心线程数 + 非核心线程数）超过这个最大值之后，就会调用RejectedExecutionHandler来处理
			- keepAliveTime:
				- 线程闲置时的过时时间，超过该时间，非核心线程就会被回收；如果核心线程也被设置允许回收，即allowCoreThreadTimeOut设置为true，那么非核心线程超时也会被回收。
			- unit:
				- keepAliveTime的单位
			- workQueue:
				- 线程池中的任务队列，凡是通过线程池的execute方法提交的Runnable的对象都将被加入到workQueue中
			- threadFactory:
				- 线程工厂，为线程池提供了创建新线程的功能
			- RejectedExecutionHandler:
				- 拒绝执行处理器：也就是当活动线程都总数超过线程池的最大线程数目时，无法再处理新增的任务，将使用四种任务拒绝的策略来进行处理
	- 线程池具有什么样的优点？
		- 降低资源消耗：重复利用已有的线程可以减少线程创建和销毁的资源开销
		- 提高响应速度：当任务到底时，不必等待线程创建就可以执行
		- 提高线程的可管理性：线程是稀缺资源，如果无限制地创建，不仅会浪费系统的资源，而且会影响系统资源的稳定性，使用线程池可以进行统一的分配、调优和监控
	- 线程池有几种？分别用于什么样的场景下？
		- newSingleThreadExecutor
			- 创建单一线程化的线程池，线程池中的任务按照固定的FIFO或者LIFO执行
		- newCachedThreadPool
			- 创建一个可缓存的线程池，当线程池长度超出处理需要，则可以回收部分线程，否则创建线程
		- newFixedThreadPool
			- 创建定长的线程池，控制线程的最大并发数，当超过时将任务放入队列
		- newScheduledThreadPool
			- 创建定长的线程池，可以定时以及周期性地执行任务
	- 线程和进程有什么区别？
		- 一个进程是一个独立的运行环境，它可以被看作是一个程序或者一个应用；而线程是进程中执行的一个任务，线程需要较少的资源就可以创建和驻留在进程中，可以共享进程中的资源。
	- 线程池的拒绝策略是什么？
		- 嗯嗯，线程池有4种拒绝策略或者说饱和策略，都是在ThreadPoolExecutor作为静态内部类来实现的：
			- ThreadPoolExecutor. AbortPolicy:
				- 这是默认的拒绝策略，直接丢弃任务并抛出RejectedExecutionException(RuntimeException的子类），该异常将有调用线程来捕获处理
			- ThreadPoolExecutor. DiscardPolicy:
				- 不做任何处理，直接抛弃任务，且并不抛出任何异常
			- ThreadPoolExecutor. DiscardOldestPolicy:
				- 直接将阻塞队列头部的第一个任务移除，将新任务加入队列。如果阻塞队列是PriorityBlockingQueue这种优先级队列，则此时优先级最高的任务将会被弹出，所以通常不建议在此时使用该策略。
			- ThreadPoolExecutor. CallerRunsPolicy:
				- 由调用线程或者说提交任务的线程来处理该任务
	- 线程池满了该怎么办？
		- 分为两类情况：
			- 如果是无界队列LinkedBlockingQueue, 可以继续将任务添加到阻塞队列中去，因为无界队列可以看成是容量无限大的队列；
			- 如果是有界队列ArrayBlockingQueue,  先看看线程的数目是否仍然小于maximumPoolSize,  如果是，那么继续往线程池里添加线程，如果已经达到最大值了，就往阻塞队列里面添加，如果添加后又满了，则只能交给RejectedExecutionHandler的拒绝策略来处理，默认是AbortPolicy.
	- JAVA中创建线程有几种方式，分别是什么？
		- 继承Thread类，需要重写run方法
		- 继承Runnable接口，实现接口中的run方法
		- 继承 Callable接口，实现call方法；将继承Callable的类的对象传入FutureTask的构造器中，得到FutureTask对象；将FutureTask对象传入Thread的构造器中，得到Thread对象
		- 创建线程池，然后用线程池来执行实现了Runnable或者Callable接口的对象
		- 利用匿名类来创建线程
		-
	- ThreadLocal有哪些内存泄漏问题？
	- ThreadLocal的底层实现原理以及常用场景？
		- 底层实现原理：
			- Thread有一个类型为ThreadLocalMap的成员变量，ThreadLocalMap是ThreadLocal的内部类，其类似于map，其key是某种泛型的ThreadLocal, value是某个具体的泛型值；这个成员变量就相当于线程的本地缓存，每个线程都有一个对应的map
			- ThreadLocal提供了get和set的访问方法。在get方法的源码里，是首先获取当前执行线程的ThreadLocalMap,  如果这个map存在，就返回key为当前ThreadLocal对象时的值；否则就调用默认的设置初始值的方法；而在设置初始值的方法里，依据ThreadLocalMap是否存在，来直接给map设置值或者创建一个新的ThreadLocalMap。get和set方法使得每个拥有该变量的线程都存在一份副本，get方法总是返回当前执行线程执行set时设置的最新值。
		- 常用场景：
			- JDBC 连接
			- Spring 事务管理
			- Session 管理
			- Spring AOP
			- 调用链、参数传递
		- 作用：
			- ThreadLocal为每个线程保存一份变量的副本，可以解决线程并发问题，
			- 例如，将JDBC的连接对象保存到ThreadLocal当中，每个线程都能保存一份自己的连接对象副本，这样就不会出现线程不安全
	- 线程池线程复用的原理是什么？
	- 线程的sleep、wait、join和yield如何使用？
	- volatile的可见性和禁止指令重排？
	- synchronized和volatile的区别？
	- CAS是什么？CAS是怎么解决并发问题的？CAS的缺点是什么？
		- CAS是compare and swap的缩写，CAS包含三个操作数：内存地址V、旧的预期值 A、将要更新的值 B， 只有当内存地址V对应的值与旧的预期值A相等时，才把V的值更新为B。整个比较和替换的操作是一个原子操作。
		- 可以举一个有并发问题的例子：有一个全局变量race，初始值为0，对应有一个对race自增1的方法，如果存在多个线程都对这个方法调用n次，就会发现多线程运行之后，race达不到n。这是因为自增操作并不是一个原子操作，其包括getstatic、iconstant、idd、putstatic四个指令，在putstatic指令中很有可能会把较小的race同步到内存中去。该例子除了使用synchronized来解决，还可以使用java.util.concurrent.atomic下的AtomicInteger的getAndIncrement()方法来替换自增操作，而这个方法的实现中用到了CAS操作：先从内存偏移量中获取值v，如果v和预期的值不一致，就不断循环重试，直到从内存中取出的值与预期值相同，再更新。
		- CAS的缺点有：
			- 循环重试的时间开销很大
			- 只能保证一个共享变量的原子操作，不能保证多个共享变量的原子操作
			- 可能会导致ABA问题：也就是说假设当前从内存中读取的值是V等于预期值A, 然后我们将其更新为B，但是这中间可能会存在一个线程将A改成B再改成A，那么CAS操作会误以为该值没有改变过。后来是通过原子引用类“AtomicStampedReference”,   通过控制变量值的版本来保证CAS的正确性
	- AQS是什么？
		- AQS的全称是AbstractQueuedSynchronizer， 抽象队列同步器，是java并发包的一个基础组件，用来实现各种锁和同步组件的。它包含 状态变量state、当前加锁线程t、等待队列q这三个核心组件。
		- 比如ReentrantLock类中就包含一个AQS对象，当调用lock方法时，就把state从0设置为1，并把加锁线程设置为当前线程，如果多次加锁或者说多次调用lock方法，那么每加锁一次，state的值就增加1；当有另外一个线程尝试lock的时候1，先试图把state从1变成0，发现当前state不为0，然后去检查当前加锁线程，发现也不是自己，于是就进入等待队列中。
	- 线程间的同步手段？用过哪些？
	-
-
- [[计算机网络]]
	- TCP和UDP的区别是？
		- TCP基于连接， UDP基于无连接
		- TCP 消耗系统资源较多，UDP消耗系统资源较少
		- UDP 的程序结构简单
		- TCP 能够保证数据正确，UDP 则可能丢包
		- TCP 能够保证数据顺序，UDP 不保证
		- TCP 只能是一对一通信，而 UDP 可以同时支持一对一、一对多、多对一以及多对多的通信
		- TCP 是面向字节流的，而 UDP 是面向报文的
	- TCP 和 UDP 分别适用于什么场景？
		- TCP 适用于要求可靠传输的应用，如文件传输系统；
		- UDP 适用于实时应用，比如直播、IP电话、视频通话
	- OSI的七层网络体系结构包含哪七层？
		- 自底向上分别是：
			- 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
	- TCP/IP协议涉及哪几层结构？
		- 一般使用四层网络体系结构: 网络接口层、网络层 IP、传输层 (TCP)、应用层（TELNET、FTP）
		- 用于说明网络原理的五层网络协议结构： 物理层、数据链路层、网络层IP、 传输层、应用层（TELNET）
	- TCP 通信过程中的连接指的是什么？
		- 连接指的是通信双方，也就是客户端和服务端各自保存的一份关于对方的信息，包括ip地址、端口号等
	- TCP 报文头部的序号和确认序号分别是什么含义？
		- 序号和确认序号都是32位。序号是用来标识连接中源端和目的端之间的字节流，只有在发送数据时才需要进行此标记；确认序号只有当ACK标志位为1时才有效，ack = seq + 1.
	- TCP 通信过程分为几个步骤？
		- 有三个步骤：连接、数据传输、关闭（退出）。通过三次握手来建立连接，通过四次握手来关闭连接。当一个连接被建立或者关闭时，交换的报文段只有TCP头部，并没有数据。
	- TCP关闭连接的四次握手是什么，为什么要进行四次握手？
		- 因为TCP是全双工，每个方向都必须单独关闭。当客户端给服务端发送一个FIN报文时，服务端只能发送一个ack确认报文，告诉服务端“你的FIN报文我收到了”，但是并不会马上关闭socket。等到服务端的数据全部发送完毕，再向客户端发送一个FIN报文，然后客户端返回一个ack确认。
	- TCP 建立连接时为什么需要三次握手，两次握手为什么不行？
		- 如果只有两次握手的话，假设服务器端向客户端发送的确认ack报文段丢失，那么此时服务端会认为连接已经建立好了，后面会发送数据，而客户端却无法判断服务端是否已经收到了报文段，也就是无法确认连接已经建立，所以不会向服务端发送数据，也不会处理服务端发过来的数据。
	- 为什么客户端在发出第四次握手后还要再等待2MSL(Maximum Segment Lifetime)才能正式释放TCP连接？
		- 还是对丢包情况的考虑，客服端向服务端的第四次握手中发送的ack报文可能会丢失，那么此时服务器端会向客户端再次发送第三次握手，也就是FIN报文段，一去一来就是2倍的最大报文段存活时间。一句话概括的话，就是为了确保服务器端受到ack确认报文。
	- 如果客户端出现了故障，服务器端该怎么做？
		- 若客户端出现故障，则服务端不能等待，白白浪费资源。
		- 服务端设置有一个保活计时器，通常是2小时，当服务端在2小时内没有收到任何来自客户端的数据时，就会每隔75s向客户端发送一个探测报文段，如果连续10次都没有得到客户端的任何响应，则任务客户端出现故障，就会关闭连接。
	- 说一下访问www.meituan.com会经过怎样的流程？
		- 第一步：从DNS服务器中获取DNS信息：查找DNS服务的过程相对复杂，首先是从浏览器的缓存里查找是否存在，若不存在再从系统缓存里查找，若不存在再从附近的路由器缓存里查找，若还不存在就再从ISP的DSN服务器中查找，若依旧不存在就从根域名的DNS服务器中查找，若根域名中还不存在，这只能说明这个域名没有进行过正式注册或者说因为欠费而导致域名被回收了；
		- 第二步：利用DNS信息从域名解析出ip地址，解析的过程是按照 一级域名、二级域名、三级域名这样的顺序进行的
		- 第三步：浏览器向该IP地址发送get类型的http或者https请求，该请求中包含了请求主机、User-Agent浏览器信息、连接信息、cookie信息等；
		- 第四步：服务器端接受并解析浏览器发送的请求，然后返回响应头和响应内容
		- 第五步：浏览器对响应头和响应内容进行解析，然后渲染在浏览器端，如果是非静态的内容，需要一点点的请求和解析才能完整地显示在浏览器端
	- 说一下TCP的拥塞控制机制？
	- 为什么TCP比UDP长一点？
	-
-
- [[Linux]]
	- 你知道哪些linux命令，知道的说一下？
		-
	- linux操作系统的设备文件有哪些？
		- 字符设备、块设备
		-
-
- [[Spring]]
	- 说说你对Spring [IOC]的理解？
		-
	- 说下你对Spring AOP的理解？
		- AOP底层是通过动态代理来实现的：接口 + 实现类
			- 如果要代理的对象实现了接口，那么Spring AOP使用JDK proxy来创建代理对象；如果没有实现接口的对象，那么使用cglib来创建一个被代理对象的子类来作为代理
	- Spring和SpringBoot的区别？
	- SpringBoot中请求进来时mapping是怎么处理的，底层是怎么实现的（如Getmapping是怎么处理请求的）？
	- Spring中连接点和切点的区别？
		- 连接点（Join Point）是应用程序中可以插入切面（Aspect）的一个点，可以是调用方法的、修改字段等地方；切点（PointCut）是指通知（Advice) 所要织入（Weaving）的程序的具体位置。
		-
	- Spring的启动过程是什么？
	- 说一下日志系统？
	- springbootApplication这个组合注解是由哪些部分组成的？
	- 说一下SpringMVC和spring的区别?
	- 说一下SpringBoot中的常见注解有哪些？
	-
- [[JVM]]
	- https://mp.weixin.qq.com/s?__biz=MzI5NjY4MDA1NQ==&mid=2247484014&idx=1&sn=fdbbf47b872d7d15389ca7d6c1ed2087&chksm=ec41ed76db36646012ebe73f7afae9c3893cacafc8a7996294e7edafcf4a34b923c003fb7c4b&scene=21#wechat_redirect
	- https://mp.weixin.qq.com/s?__biz=MzI5NjY4MDA1NQ==&mid=2247484067&idx=1&sn=ba998009dc76ee94e05910c52c04b54b&chksm=ec41edbbdb3664adb57e91dd1abaf868e0d879d2f3c17d3865502730d511ed42a836c87b3b0f&scene=21#wechat_redirect
	-
-
- [[垃圾回收]]
	- 如何解决线上GC频繁的问题？
	- 有哪些垃圾回收算法？
	- jvm中有哪些垃圾回收器，实际如何选择？
-
- [[NIO]]
  collapsed:: true
	- JAVA NIO是什么？
	- Lambda 表达式是什么？具有什么样的优点？
	- Lambda表达式的作用域是什么？
-
- [[微服务]]
	- 什么是微服务架构？
		- 微服务就是把单体的应用程序划分为多个应用程序，这多个应用程序就是微服务体系，每个微服务运行在自己的进程中，并通过轻量的机制进行通信。微服务按照业务功能进行划分，并通过自动化的部署机制进行独立部署。每个微服务可以使用不同的编程语言，不同的数据库，以保证最低限度的集中式管理。
	- 微服务具有什么样的特点?
		- 解耦
			- 系统内的各个服务相对分离，整个应用程序的构建、更新和升级因而也变得容易
		- 组件化
			- 微服务可以视作一个可以更新和升级的独立组件
		- 业务能力
			- 微服务的功能简单，通常是单一功能
		- 敏捷
			- 微服务支持敏捷开发
		- 责任
			- 不再把整个项目当作产品，而是把每个应用程序当作产品
		- 持续交付
			- 软件的创建、测试和审核都可以自动化完成，软件可以频繁地进行发布
		- 自治
			- 开发人员和团队可以独立工作，大大加快了开发速度
		- 分散职责
			- 没有技术模式，开发人员可以自由选择最有用的工具来完成需要实现的功能
			-
		-
-
- [[DesignPattern(设计模式)]]
	-
- [[数据结构与算法]]
	- [[数据结构]]
	- [[排序算法]]
-
-