- HashMap和HashTable的区别？
  collapsed:: true
	- 线程安全：
		- HashTable的所有方法都使用synchronized来修饰，是线程安全的，而HashMap是线程不安全的，因此HashMap的效率也更高
	- 用法：
		- HashMap的key和value都可以为null，而HashTable不可以
		- HashTable的contains(Object value)和containsValue(Object value)的功能一样，都是判断是否存在某个特定的value
		- HashMap使用Iterator来进行遍历，而HashTable使用Enumeration来遍历
	- 原理：
		- HashTable的hash数组默认大小是11，扩容时是old * 2 + 1；HashMap的hash数组默认大小是16，而且一定是2的指数
		- 哈希值的计算方式不同：HashTable直接使用对应的hashCode()方法来计算；而HashMap则重新计算hash值，且用与运算来代替求模运算
		- HashTable是基于陈旧的Dictionary类的，而HashMap是JAVA 1.2 引进的Map接口的一个实现
		-
- HashMap和ConcurrentHashMap的区别？
  collapsed:: true
	- ConcurrentHashMap其在JDK 1.5之后出现。两者并不出现在同一个包中，两者的父类在一个包中，但是子类不在一个包中。
	- HashMap是非线程安全的，但是ConcurrentHashMap（并发包下的）是线程安全的，其降低了加锁的粒度。ConcurrentHashMap在HashMap的基础上，将数据划分为多个segment, 默认是16个(Concurrency Level),  每次操作对一个segment加锁，降低了多线程锁得几率，提高并发效率。在并发读取时，除了key对应的value为null值外，并没有加锁。
- JAVA中如何实现代理机制？
  collapsed:: true
	- JDK动态代理：
		- 代理类和目标类实现相同的接口，用到InvocationHandler接口
	- CGLIB 代理：
		- 代理类是目标类的子类，用到MethodInterceptor接口
		-
- ArrayList和LinkedList的区别？
  collapsed:: true
	- 前者由数组实现，后者由双向链表实现，因而ArrayList进行增加、删除操作比LinkedList慢，但是ArrayList进行查找和修改值时需要进行递归
	- LinkedList同时还实现了Queue接口，因而还具有offer、poll、peek等操作
	- ArrayList是非线程安全的，另外一个也是基于数组的List接口实现类Vector，其是线程安全的。但是一般来说，在多线程方面更多使用CopyOnWriteArrayList，其适合诸如缓存等读操作远远多于写操作的场景，发生修改时做拷贝，新老版本进行分离，保持了读的高性能
	-
- JVM对象的内存空间包含哪几个部分？其中的对象头包含哪些信息？
  collapsed:: true
	- 包含markword(与电脑的位数相同，64位电脑就是8B，32位电脑就是4B)、class pointer（指向obj.class），instance data(类的成员变量数据，但是字符串引用类型的成员变量的大小只有4字节，与字符串的长度没有关联）,  padding(确保字节的总数目是4的倍数，比如当前只有17个字节，那么需要补充3个字节使其变成20个字节）
	- 对象头由markword和class pointer组成，即object header
	- 对象头包含三类信息：
		- 锁信息：
			- 当synchronized(obj){ClassLayout.parseInstance(obj).toPrintable()}时，默认在对象头的markword中加入锁信息，一般是轻量级的自旋锁。
		- hashcode信息
			- 当调用obj.hashCode()后，其哈希信息被记录在了该对象obj的markword中，所以下次再调用hashCode时，不用重新计算，而是直接在markword中取出来
		- GC
			- 现在JVM的垃圾回收算法用的是三色标记，所以markword记录了对应的“颜色”
			-
- JVM中的对象该如何定位？
- 字符串对象一定在栈上吗？
	- 不一定，因为该字符串对象可能是某个对象的成员变量
- JDK1.8使用的垃圾回收算法是什么？
	- 使用的是 PS + PO 算法
- java中的对象都是放在堆上吗？
  collapsed:: true
	- main函数中声明的局部变量都放置在栈上
	- 栈中方法区的局部变量，当当前方法结束时，系统会自动回收栈中该方法的空间，也就是将栈中的指针指向调用当前方法的上一个方法，这块区域的回收并没有用到垃圾回收器
	- 但是栈的默认空间比较小，只有256K，且并不是所有对象都适合放在栈中
	- 判断对象是否放在栈上有两个标准：
		- 一是逃逸分析：如果该对象被其他对象所引用，那么不能放在栈中，也就是要分析对象的作用范围是否为逃逸出方法的范围，
		- 二是标量替换：只有最基础的数据类型才能替换
		-
- java中对象的创建过程？
  collapsed:: true
	- 分为三步：第一步是new操作，为对象在内存当中分配空间，按照markword、class pointer、instance data和padding的存储结构来分配，对象的成员变量使用默认的初始值；第二步是调用构造器，完成对象的初始化，包括成员变量值的显示赋值；第三步是建立关联，将引用变量 赋值为 对象的内存地址。
- 为啥要使用double check lock?
  collapsed:: true
	- 实际上只加了一个synchronized关键字在函数的内部，这里的lock指的是对象不为空的这个判断操作。里面的第一个lock（内部的lock），是为了保证instance的同步，如果当前线程已经在创建对象了，给当前线程加锁，那么其他线程无法执行当前代码块，也就是根本都不会去判断instance实例是否不为空，更不用说会去创建对象了，等到当前线程解锁，其他线程都会判断 instance != null 为false，所以也都不会继续创建对象了；里面的第二个lock (外部的lock)，如果不加上，导致的问题是每个其他进程都在加锁这一步等待，而加锁操作非常耗时，如果加上外部的判断，可以同样起到不创建对象操作的目的，但是会大幅提高速度，进而提高并发性能。
	- ```
	  if(instance ! = null){
	  	synchronized (A.class){
	         if(instance ! = null){
	         		try{
	              	A a = new A（）;
	              } catch(Exception e){
	              	
	              }
	         }
	      }
	  }
	  
	  ```
- Class实例究竟在Method area还是在Heap中？
  collapsed:: true
	- ![image.png](../assets/image_1678967682039_0.png)
	-
-
- 什么是数据库的事务？
  collapsed:: true
	- 事务是一组逻辑操作，要么都执行，要么都不执行。它是数据库并发调度的基本单位，其执行的结果必须使数据库从一种一致性状态转换到另一种一致性状态。
	- 举例来说就在A给B转账，给A的账号减小m元和给B的账号增加m元，这两个操作必须都执行或者都不执行，如果A执行了但是B不执行，这样就不对了。
- 事务的ACID特性指的是什么？
  collapsed:: true
	- Atomicity 原子性：
		- 事务的执行具有原子性，要么都执行，要么都不执行，不能分开；事务是最小的执行单元
	- Consistency 一致性：
		- 在事务执行前后，数据库中的数据始终保持一致，不同事务对于同一数据的读取结果应该是相同的
	- Isolation 隔离性：
		- 并发访问数据库时，一个用户的事务并不受到其他事务的干扰，各个并发事务之间数据库是独立的
	- Durability 持久性：
		- 事务对数据库的改变是持久的，即使数据库崩溃了也不会这一点所有改变
- 事务的隔离级别有哪些？MySql和Oracle的隔离级别是什么？
  collapsed:: true
	- 事务的隔离级别有四种：
		- Read-Uncommited (读取未提交)：
			- 是最低的隔离级别，允许读取尚未提交的数据更新，脏读、幻读和不可重复读仍然有可能发生
		- Read-Commited (读取已提交)
			- 允许读取并发事务已经提交的数据更新，可以阻止脏读，但是幻读和不可重复读仍然有可能发生
		- Repeatable-Read (可重复读)
			- 对同一字段的多次读取结果是完全一致的，可以阻止脏读和不可重复读，但是幻读仍然有可能发生
		- Serializable (可串行化)：
			- 完全满足ACID原则的最高隔离级别，各个事务之间串行执行，也就不存在相互干扰，也就是说可以完全阻止脏读、幻读和不可重复读
	- MySql的隔离级别是 REPEATABLE_READ,  Oracle的隔离级别要比Mysql低一级，也就是READ_COMMITED
- 如何理解事务隔离机制？
  collapsed:: true
	- 事务隔离机制是基于锁和并发调度实现的。其中并发调度使用的是MVCC(Multiversion Concurrency Control), 即多版本的并发控制，通过保存修改过的旧版本信息来实现并发一致性的读和回滚特性
- 什么是脏读、幻读和不可重复读？
  collapsed:: true
	- Dirty Read:
		- 一个事务已经提交了数据更新，此时另外一个事务读取这个数据，但是前面的事务进行了rollback操作，那么后面这个数据读取到的数据就是不正确的了
	- Phantom Read:
		- 一次事务两次查询之间读取到的数据记录数目不一样，应该是两次查询间有其他事务插入了新的数据记录
	- UnRepeatable Read:
		- 一次事务两次查询的结果是不同的，应该是两次查询之间有其他事务对部分数据进行了更新
- 对MySql的锁了解吗？
  collapsed:: true
	- 锁是一种保证访问次序的机制，为了减小或者避免数据库中并发事务导致的数据不一致的问题。
	- 当一个事务加上锁之后，其他事务必须等待锁释放才能访问和修改对应的数据。这就像酒店房间的锁，多个人同时申请一个房间，但是只有一个人会获得这把锁，然后使用该房间，只有当这个人归还钥匙房间时，剩下人中的一个才能使用。
- 按照锁的粒度有哪些锁？
  collapsed:: true
	- 可以分为行级锁、页级锁、以及表级锁
	- 行级锁只对当前操作的行进行加锁，表级锁只对当前操作的整张数据表进行加锁，而页级锁则采取了折衷的方案，对当前操作的页进行加锁，一次锁定一组数据记录
	- 三类锁的加锁开销和加锁时间依次递增；因为粒度越细，造成的冲突次数也就越少，所以三者的并发度是在依次递减的；三者中行级锁和页级锁都有可能发生死锁，但是表级锁不会发生死锁；行级锁可以分为共享锁和排他锁，表级锁也可以分为表共享读锁(共享锁）和表独占写锁（排他锁）
- MySql支持的锁的粒度是什么？
	- 取决于具体的存储引擎：如果是MYISAM引擎，则支持表级锁；如果是INNODB引擎，则支持行级锁和表级锁，默认使用行级锁
- 按照锁的类别有哪些锁？
	- 类别上分为共享锁和
- 数据库的乐观锁、悲观锁分别是什么？
- 什么是死锁，怎么解决？
- 大部分数据库采用什么隔离级别?
  collapsed:: true
	- 大部分都采用READ_COMMITED的隔离级别，能阻止脏读，但是不可重复读和幻读仍然有可能发生
	- InnoDB存储引擎默认使用READ_COMMITED并不会有任何性能损失，其只有在分布式事务的情况下才会使用Serializable的隔离级别
	-
- 数据库的三大范式是什么？
  collapsed:: true
	- 第一范式：数据库的所有列都不可再拆分
	- 第二范式：在第一范式的基础上，非主键列完全依赖于主键，不能是只依赖于主键的一部分
	- 第三范式：在第二范式的基础上，非主键列只能依赖于主键列，不能依赖于其他非主键列
	- 在进行数据库的设计时，要尽量遵守三大范式，但是经常为了性能的原因而妥协数据库的设计。
- VARCHAR和CHAR类型的比较？
  collapsed:: true
	- varchar可以用于存储变长的字符串，比char类型更节省空间；varchar通常使用1到2个字节来记录长度，当长度不超过255个字节时，使用一个字节来存储长度，否则用两个字节
	- char用于存储定长的字符串
		- 一是当需要频繁进行变更时，char比varchar更适合，因为会有更少的内存碎片；
		- 二是对于非常短的列，使用char更合适，因为更长的列会在排序时会消耗更多的内存空间
	- 对于TEXT/BLOB类型，尽量不要使用，因为其在查询时会需要用到临时表，会有严重的内存开销
- 索引是什么？
  collapsed:: true
	- 索引是数据库管理系统中用于排序的一种数据结构，可以方便地对数据库进行快速的查询和更新操作，索引通常通过B树和B+树来进行实现
	- 索引是一种特殊的文件（InnoDB数据表的索引是表空间的一部分），包含了数据库中所有记录的指针引用
	- 更通俗地来说，索引就相当于目录，对文件内容建立索引方便查找具体的记录，索引本身是一个文件，因而会占据一定的物理空间
- 索引有哪些优缺点？
  collapsed:: true
	- 两个优点：
		- 大大加快了数据查询的速度，这也是使用索引最为主要的原因
		- 在使用索引进行查询时，可以使用优化隐藏器，提高了系统性能
	- 两个缺点：
		- 创建索引和维护索引需要花费时间，当对数据记录进行增删改时，对应的索引也需要进行增删改
		- 索引需要使用一定的空间
- 怎么样能够提高索引的效率呢？
  collapsed:: true
	- 对join语句匹配关系的on涉及的字段建立索引，能够提高效率
- 什么是覆盖索引？
  collapsed:: true
	- 如果待查询的字段都已经建立了索引，那么执行引擎就会直接在索引表里进行查询而不是直接访问原始数据，这就叫做覆盖索引，否则只要有一个查询字段没有索引，都需要进行全表扫描
	- 所以仔细选择select后的查询字段，使其在覆盖索引的字段范围内，能够提高查询效率
	- 因为索引能提高效率主要就是因为体积小，所以不建议为了覆盖索引而给过多的字段设置索引
- 怎么避免不可重复读？
  collapsed:: true
	-
- 说说你对Spring [IOC](https://so.csdn.net/so/search?q=IOC&spm=1001.2101.3001.7020)的理解？
- B树和B+树的区别？两者各自的优点是什么？数据库为啥使用B+树而不是B树？
  collapsed:: true
	- B树的内部节点和叶子节点都包括键和值，但是B+树内部节点只包括键，叶子节点同时包括键和值；B树的叶子节点之间没有关联或者说各自独立，B+树的叶子节点通过类似于链表的方式进行单向串联
	- B树中每个节点都包括键和值，所以把查询频率高的热点数据放在根节点附近，就可以大大提高查询效率，这适用于特定数据进行多次重复查询访问的场景
	- B+树中有两个优点: B+树的内部节点只有键，没有值，所以在内存页中可以存储更多的键值，有利于更快地缩小查询范围； B+树的叶子节点通过一条链进行相连，当需要进行全表查询时，先花费O(logN)的时间找到最小的节点，再沿着链花费O(N)时间进行查找，而B树则需要在每一层进行遍历，这需要更多的内存页置换次数，也就会花费更多的时间
	- 可以从三个方面来说明数据库使用B+树的原因：
		- 查询功能：
			- B树只支持随机索引，而B+树同时支持随机索引和顺序索引
		- 空间效率：
			- B+树的空间利用率更高，减少了磁盘IO的读写次数。因为B+树的内部节点只存储了键而没有存储关键字对应的指针，比B树的内部节点小，所以盘块中存储的节点关键字数量也更多，一次性从内存中读取的关键字数量也越多。
		- 查询效率：
			- B+树的查询效率更加稳定：
				- B树的性能等价于对关键字集合进行一次二分查找，越靠近根节点的关键字查询效率越高；而B+树中的叶子节点存放键和值，所以任何关键字段查询都需要从根节点到叶子节点，每个关键字的查询效率是相近的
				- B+树中可以沿着叶子节点间的链进行全表查询，方便基于数据库的范围查询操作和节点的增删操作
				-
	-
-
-
-
- Spring和SpringBoot的区别？
-