- [[阿里]]
	- 场景题两题都没有答上来，根本没有准备场景题：
	  collapsed:: true
		- 场景一：
			- 给定一个用户的空间坐标，设计一种算法找出这个用户最近的门店，当然用户附近可能没有这个门店。用户附近指的是三公里以内的，没有固定形状的。
		- 场景二：倒排索引
			- 敏感词查询：针对敏感词我们有一个对应的语料库，语料库中的每个语料是一个完整的语句，现在给定一个关键字，让你找出包含这个关键字的所有语句
	- 操作系统中的Page fault是什么？发生了Page Fault, 有什么算法可以解决？
	- 你说对中间件了解得相对深刻，那么你的连接池是在客户端还是在服务端的？你说你没有用链接池，使用的是动态数据源，那么你没有发觉使用动态数据源这种方式有什么缺点吗？
	- 你说过学习过SpringIOC，那么JDK Proxy和Cglib两种代理具体是怎么实现的？有什么区别？
	- BeanPostProcessor 和 BeanFactoryProcessor 有什么区别？
	- 你对MQ、Redis有深入了解吗？
	- 说一下你对注册中心的理解？
	- 你对dubbo有所学习和理解吗？
	- 为什么要用DDD架构, 而不是用MVC？ MVC设计得好也不会有耦合问题，DDD设计得不好也会有耦合问题，所以到底为什么要用DDD？DDD中领域服务下面有一个aggregates，说说你的理解？什么样的东西适合放在aggregate里面？
	- 说一说数据库索引里面的最左前缀原则？
	- 你了解Full GC吗？你在真实场景中碰到过Full  GC吗？
	  collapsed:: true
		- Full GC 是清理整个堆空间，包括新生代和老年代
		- 发生的场景：
			- 调用System.gc
			- promotion failed，也就是晋升失败：
				- 比如eden区的存活对象晋升到S区发现放不下，又尝试直接晋升到old区发现还是放不下，也就是晋升失败
			- CMF也就是Concurrent-Mode-Failure， 并发模式失败
				- CMS包含初始标记、并发标记、重新标记、并发清除这四个步骤，在第二步的并发标记中，用户线程和gc线程同步进行，用户线程新产生的垃圾若无法放入预留的空间，则会产生并发模式失败，就会切换到 serialOld单线程做 标记-清除-整理
	- SpringBoot使用得非常熟练吗？什么情况下会报错找不到Bean?
	  collapsed:: true
		- 我回答了：没有写@Bean注解、ComponentScan里没有写，问还有哪些？
		- 我说：路径错误，面试官答：路径错误就会报编译错误了
		- 修正回答：
			- 当程序中找不到所需的Bean时，会抛出BeanNotFoundException，可能原因包括两方面：
				- 一是没有正确地配置Bean
					- 这个Bean对应的类没有写到应用程序中去
					- 这个Bean对应的类没有写上@Bean注解或者@Component注解
					- 这个Bean的类型或者名称 和 注入Bean的代码部分不匹配：如果使用@Resource注解，可能的原因包括name与Bean的名称不一致、有多个同一接口的实现类但并没有使用@Qualifier注解、有多个同一接口的实现类且使用了@Qualifier注解但是其中的name写错；如果使用@Autowired注解，可能的原因包括有多个同一接口的实现类但没有使用@Primary或者@Qualifier注解、使用了@Qualifier注解但是其中参数name的值写错
					- 这个 Bean 没有被扫描到：比如@ComponentScan中不包含Bean所在的目录
				- 二是依赖问题
					- 没有引入需要的依赖或者依赖的版本错误
					- 在多模块项目中，存在依赖冲突或者重复依赖
	- 说一下类加载机制？
	- SpringBoot怎么解决依赖冲突？
	  collapsed:: true
		- 使用最新的依赖版本
		- 在pom文件中使用exclude来排除冲突的依赖
		- 使用IDEA的dependency analyzer来对依赖进行统一管理
		- 尽量使用springboot内置的依赖性，因为这些依赖项已经测试过且与当前的SpringBoot兼容
		- 查阅源代码和相关文档，手动解决
	- 什么是SpringBoot中的starter？springboot starter背后的原理是什么？阅读过相关的源码吗？
	  collapsed:: true
		- https://www.cnblogs.com/tjudzj/p/8758391.html
			- starter可以视为一组依赖的合成 (synthesizing),  其可以实现自动的组件装配和依赖管理，大大简化了项目的开发。比如说：在没有starter之前，我们要在spring中使用JPA，那么需要先引入jdbc这个数据库的依赖、然后再引入jpa的依赖、接着还有在XX.xml文件中配置一些属性信息，最后反复调试直到能够运行；但是这个过程繁琐且容易出错，并且在其他项目再次用到时需要拷贝粘贴同一段冗余的代码；有了starter，所需的依赖就会被starter自动地引入进来，而不需要开发者手动引入这些依赖。
			- starter实现的具体思路：
				- 尽管各种starter实现起来有所差异，但是基本上都包含两个核心部分：
					- 第一个是ConfigurationProperties
						- 用来保存我们的属性配置，在这个配置里我们写入各种默认值，且其可以把所有的配置属性聚集到一个文件当中，这个文件通常是resources目录下的application.properties,  如果用户后续在调用该starter项目中的application.properties覆写了相关属性的值，那么对应的属性就会被覆盖，否则就直接使用starter中的默认值；
					- 第二个是AutoConfiguration
						- 其会把属性配置引入，在这个类中实现所有starter需要执行的操作，需要在spring.factories中对这个类进行声明
	-
- [[众安保险]]
	- springboot相比于spring有什么优点？是spring的脚手架吗？
	- 结合B+树的索引结构说一下在什么情况下索引会失效？
	  collapsed:: true
		- https://bbs.huaweicloud.com/blogs/333163
			- 对索引使用左模糊匹配或者左右模糊匹配时
				- 比如使用sql语句 "select * from table student where name like %明" 或者 “select * from table student where name like %明%”，查询姓名以明字结尾的学生的身份信息
				- 因为B+索引树是按照索引值进行有序排列的，所以只能按照前缀来进行比较和查找，如果是左模糊匹配，比如%明，这满足的可能是 李明、张明、韩明等，无法按照前缀来进行比较，自然也无法沿着B+树进行搜索，所以只能使用全表查询了
			- 对索引使用函数
			  collapsed:: true
				- 比如“select * from table student where length(name) = 6”
				- 因为索引树中的key保存的是索引字段的原始值，而不是索引字段经过函数计算后的值
			- 对索引进行表达式的计算
				- select * from table student where id + 1 = 10
				- 如果改写成 id = 10 - 1 则没有问题
			- 对索引进行隐式类型转化
				- 比如 给一个字符串类型的字段 赋 整数值：“select * from table student where phone = 1300001”
				- 因为mysql默认是把字符串转换成整数，所以这里相当于是把phone这个索引字段加上了一个字符串转整数 的函数；如果反过来，给一个int类型的字段赋值数字字符串，如phone = “13000”，是没有问题的
			- 联合索引非最左匹配
				- 联合索引是指多个普通字段一起创建的索引，如果联合索引不遵守最左匹配原则，那么就无法在索引树中进行搜索了，比如联合索引（a, b, c），如果查询条件中并没有a这一列，那么直接第二列或者其他后续列开始查询是不行的
			- Where子句中含有or，并且or前是索引列，or后不是索引列
				-
	- @Autowired和@Resource进行JAVA Bean的注入有什么区别?
	  collapsed:: true
		- 两者都可以作为属性注入的注解，但只有一个接口的实现类时，两者可以相互替换，并不影响使用
		- 区别：
			- @Resource是JDK自带的原生注解，而@Autowired是Spring2.5才引入的
			- @Resoure有name和type两个属性，name表示的是注入Bean的name，type表示的是注入Bean的类型。如果指定了name的属性值，那么使用byName的自动注入策略；如果指定了type的属性值，那么使用byType的自动注入策略；如果name和type的属性值都没有指定，那么默认使用反射机制获取name通过byName方式进行自动注入
			- @Autowired 按照type进行注入，不匹配name。当有多个接口的实现类时，依据type无法判断选择哪个具体的Bean进行注入，可以使用@Primary或者@Qualifier来解决，@Primary是写在要选择的那个实现类上，而@Quaifier("")是写在需要注入的那个属性上，括号里写上的是对应的实现类的类名（但是首字母要改成小写）。
	- 线程池管理线程的一个流程大概是什么？
	- http和https有什么区别？哪个才是加密的？
	  collapsed:: true
		- http是明文传输，数据并没有加密，安全性比较差；而https(ssl + http)的数据进行了加密，安全性较高
		- https需要申请CA (Certificate Authority数字证书认证机构)，而CA只有少数是免费的，所以https网站需要更高的花费
		- http 的页面响应速度比 https要快，因为http 建立连接是TCP的三次握手，客户端和服务端需要先后交换三个包，而https 除了TCP的三次握手，还需要ssl 握手的9个包，所以一共是12个包
		- http 和 https 使用的是完全不同的连接方式，端口也不同，http 是 80 端口，而https 是 443端口
		- https其实就是建立在 SSL/ TLS上的http连接，因而会消耗更多的服务器资源
	- ThreadLocal什么情况下会导致内存泄漏？怎么使用ThreadLocal才恰当？
	  collapsed:: true
		- https://zhuanlan.zhihu.com/p/102571059
		  id:: 642af135-8ab5-4f5b-b518-3d119152df35
			- 每一个Thread都对应有一个ThreadLocalMap, 这个ThreadLocalMap里的每个Entry的key都对应于一个WeakReference包装的ThreadLocal，value都对应于一个局部变量的值。当需要回收一个ThreadLocal对象时，由于ThreadLocalMap和Thread的生命周期一样长，Thread当前依旧存活，那么ThreadLocalMap对象也依旧存活，那么前面需要回收的那个ThreadLocal对象对应的Entry也就依旧存活，Entry中的key不为null，这样就造成了内存泄漏，因为这时候的垃圾回收器无法判断依据key是否为null来判断哪些Entry是需要被回收的。
			- 这种内存泄漏，本质上是因为长生命周期的对象持有短生命周期的对象，导致短生命周期的对象无法被回收。
			- 解决办法是显示调用ThreadLocal的remove()方法，方法的参数是ThreadLocal，这样需要被回收的Entry的key就是null了。
		- 下面两篇英文博客都说明了 在运行在应用服务器上的JAVA EE 应用上使用ThreadLocal容易造成内存泄漏，如果使用了一般使用ServletFilter来解决
		  collapsed:: true
			- https://blog.codecentric.de/a-threadlocal-memory-leak
			- https://javarevisited.blogspot.com/2013/01/threadlocal-memory-leak-in-java-web.html#axzz7xsJPfzyf
			  id:: 642af144-5c1a-4c52-991c-9b99f4d9ee0e
				- 不理解为什么说工作线程的生命周期要比web app本身要长？
				-
		- 两点使用ThreadLocal的建议：
			- 每次使用完ThreadLocal方法都调用remove将其清除掉
			- 建议把ThreadLocal变量声明为private static, 这样一来key必然为强引用，同时key会因为作为GC roots而永远不会被回收，此时key是否为weakreference已经不重要了。static表明只会存在一个ThreadLocal对象，即使是一个不发生异常永远存活的线程池中的线程，这个ThreadLocal对象也只会占用该线程的ThreadLocalMap中的一个Entry的位置，所以即便永远不回收也没有关系。但是如果是局部的ThreadLocal变量，线程每run一次，就可能会生成一个新的Entry,  如果不调用remove，每次就会有一个新的ThreadLocal变量发生内存泄漏，这样下去内存泄漏就会不断累计，甚至会造成OOM。
	- ThreadLocalMap中的ThreadLocal为什么需要不能使用强引用，而使用弱引用？
	  collapsed:: true
		- 如果是强引用，那么根据JVM的垃圾回收原理，当回收ThreadLocal时，由于ThreadLocalMap还持有ThreadLocal的强引用，导致ThreadLocal无法被回收，Entry产生内存泄漏
	- 引用计数法来寻找哪些对象需要进行回收有什么缺点？
	  collapsed:: true
		- 因为 互相引用的情况 无法识别，比如 A引用B, B又引用A，那么A和B的引用计数都是1，但是实际上两者都可能不再被使用了
	- 你对ZOOKeepr和ElasticSearch有什么学习和理解吗？
	- 你觉得Mybatis在使用时有什么不方便的地方吗？
	- 你知道TCP的拥塞控制吗？
	- OOM会有哪些可能的情况？
	- synchronized是怎么实现的？
- [[从群友或者牛客上收集的面试题]]
	- 说说什么是两阶段提交？
	- 链路关系怎么进行设计？
	-
-